<?xml version="1.0"?>
<doc>
    <assembly>
        <name>mapf</name>
    </assembly>
    <members>
        <member name="F:mapf.AgentState.h">
            <summary>
            Only used when AgentState objects are put in the open list priority queue - mainly in AStarForSingleAgent, I think.
            </summary>
        </member>
        <member name="F:mapf.AgentState.arrivalTime">
            <summary>
            At goal
            </summary>
        </member>
        <member name="F:mapf.AgentState.lastMove">
            <summary>
            The last move's time is the agent's G
            </summary>
        </member>
        <member name="F:mapf.AgentState.prev">
            <summary>
            Only used by AStarForSingleAgent, which should itself be deleted.
            </summary>
        </member>
        <member name="F:mapf.AgentState.EquivalenceOverDifferentTimes">
            <summary>
            For CBS this must be set to false.
            </summary>
        </member>
        <member name="M:mapf.AgentState.SwapCurrentWithGoal">
            <summary>
            Only used by EnumeratedPDB - check if can be removed
            </summary>
        </member>
        <member name="M:mapf.AgentState.MoveTo(mapf.TimedMove)">
            <summary>
            Updates the agent's last move with the given move and sets arrivalTime (at goal) if necessary.
            </summary>
        </member>
        <member name="M:mapf.AgentState.AtGoal">
            <summary>
            Checks if the agent is at its goal location
            </summary>
            <returns>True if the agent has reached its goal location</returns>
        </member>
        <member name="M:mapf.AgentState.GetIndexInHeap">
            <summary>
            BH_Item implementation
            </summary>
        </member>
        <member name="M:mapf.AgentState.SetIndexInHeap(System.Int32)">
            <summary>
            BH_Item implementation
            </summary>
        </member>
        <member name="M:mapf.AgentState.Equals(System.Object)">
            <summary>
            When equivalence over different times is necessary,
            checks this.agent and last position only,
            ignoring data that would make this state different to other equivalent states:
            It doesn't matter from which direction the agent got to its current location.
            It's also necessary to ignore the agents' move time - we want the same positions
            in any time to be equivalent.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.AgentState.GetHashCode">
            <summary>
            When equivalence over different times is necessary,
            uses this.agent and last position only, ignoring direction and time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.AgentState.CompareTo(mapf.IBinaryHeapItem)">
            <summary>
            Used when AgentState objects are put in the open list priority queue - mainly in AStarForSingleAgent, I think.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.A_Star">
            <summary>
            This is an implementation of the A* algorithm for the MAPF problem.
            It r
            </summary>
        </member>
        <member name="F:mapf.A_Star.solutionDepth">
            <summary>
            How much more expensive the solution was than the heuristic's initial estimate
            </summary>
        </member>
        <member name="F:mapf.A_Star.bpmxBoosts">
            <summary>
            Note we can boost nodes that aren't eventually counted as generated (already in the closed list, too costly, ...)
            </summary>
        </member>
        <member name="F:mapf.A_Star.totalCost">
            <summary>
            Holds the cost of the solution when a solution found
            </summary>
        </member>
        <member name="F:mapf.A_Star.mustConstraints">
            <summary>
            An array of dictionaries that map constrained timesteps to must constraints.
            </summary>
        </member>
        <member name="M:mapf.A_Star.#ctor(mapf.IHeuristicCalculator{mapf.WorldState},System.Boolean,System.Boolean)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:mapf.A_Star.Setup(mapf.ProblemInstance,System.Int32,mapf.Run,System.Int32,System.Int32,mapf.MDD)">
            <summary>
            Setup the relevant data structures for a run under CBS.
            </summary>
        </member>
        <member name="M:mapf.A_Star.CreateSearchRoot(System.Int32,System.Int32,mapf.MDDNode)">
            <summary>
            Factory method. Creates the initial state from which the search will start. 
            This will be the first state to be inserted to OPEN.
            </summary>
            <returns>The root of the search tree</returns>
        </member>
        <member name="M:mapf.A_Star.Clear">
            <summary>
            Clears the relevant data structures and variables to free memory.
            </summary>
        </member>
        <member name="M:mapf.A_Star.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.A_Star.Solve">
            <summary>
            Runs the algorithm until the problem is solved or memory/time is exhausted
            </summary>
            <returns>True if solved</returns>
        </member>
        <member name="M:mapf.A_Star.Expand(mapf.WorldState)">
            <summary>
            Expand a given node. This includes:
            - Generating all possible children
            - Inserting them to OPEN
            - Insert the generated nodes to the hashtable of nodes, currently implemented together with the closed list.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:mapf.A_Star.ExpandOneAgent(System.Collections.Generic.List{mapf.WorldState},System.Int32)">
            <summary>
            Expands a single agent in the nodes.
            This includes:
            - Generating the children
            - Inserting them into OPEN
            - Insert node into CLOSED
            Returns the child nodes
            </summary>
        </member>
        <member name="M:mapf.A_Star.CreateSearchNode(mapf.WorldState)">
            <summary>
            Factory method.
            </summary>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="F:mapf.A_Star.queryConstraint">
            <summary>
            Just an optimization
            </summary>
        </member>
        <member name="M:mapf.A_Star.IsValid(mapf.TimedMove,System.Collections.Generic.IReadOnlyDictionary{mapf.TimedMove,System.Int32},System.Int32,System.Int32,mapf.WorldState,mapf.WorldState)">
            <summary>
            Check if the move is valid, i.e. not colliding into walls or other agents.
            This method is here instead of in ProblemInstance to enable algorithmic tweaks.
            NOTE: This method is pasted into ExpandOneAgent. Be sure to update anything in both places!
            </summary>
            <param name="possibleMove">The move to check if possible</param>
            <param name="currentMoves"></param>
            <param name="makespan"></param>
            <param name="agentIndex"></param>
            <param name="fromNode"></param>
            <param name="intermediateMode"></param>
            <returns>true, if the move is possible.</returns>
        </member>
        <member name="M:mapf.A_Star.GetPlan">
            <summary>
            Returns the found plan, or null if no plan was found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.A_Star.ProcessGeneratedNode(mapf.WorldState)">
            <summary>
            Checks for closed list hits and handles them, check the max cost, does book-keeping
            of conflict counts, etc.
            </summary>
            <param name="currentNode"></param>
            <returns>Returns whether the node was inserted into the open list.</returns>
        </member>
        <member name="M:mapf.A_Star.RMStarCollisionBackPropagation(mapf.CbsConflict,mapf.WorldState)">
            <summary>
            NOT the algorithm in the M* journal paper.
            They want each node to propagate its entire collision set, not just the new conflict that began the process.
            This implementation may be suitable for the M* algorithm as appears in the paper,
            but it isn't suitable when we want to backpropagate from a closed list hit,
            because then we don't have a specific conflict to propagate.
            </summary>
            <param name="conflict"></param>
            <param name="fromNode">
            Not the node where the collision happened, because it was never generated.
            The node from where the colliding moves were made.
            </param>
        </member>
        <member name="M:mapf.A_Star.RMStarCollisionBackPropagation(mapf.DisjointSets{System.Int32},mapf.WorldState)">
            <summary>
            Not the paper's version either, since it always propagates the same collision sets.
            </summary>
            <param name="colSets">The collision sets of the _child_ of fromNode</param>
            <param name="fromNode"></param>
        </member>
        <member name="T:mapf.A_Star_MDD">
            <summary>
            Finds the solution with the least number of conflicts, given a set of MDDs
            </summary>
        </member>
        <member name="M:mapf.MDDStep.Equals(System.Object)">
            <summary>
            Only compares the steps.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.MDDStep.GetHashCode">
            <summary>
            Only uses the steps
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.MDDStep.SetConflicts(System.Collections.Generic.Dictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}},System.Collections.Generic.Dictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Updates the conflicts member according to given CATs. Both tables may be null.
            </summary>
            <param name="ID_CAT"></param>
            <param name="CBS_CAT"></param>
        </member>
        <member name="M:mapf.MDDStep.GetIndexInHeap">
            <summary>
            BH_Item implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.MDDStep.SetIndexInHeap(System.Int32)">
            <summary>
            BH_Item implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.ExpandedNode.GetNextChild">
            <summary>
            
            </summary>
            <returns>The next child, or null if there aren't any more</returns>
        </member>
        <member name="T:mapf.A_Star_WithOD">
            <summary>
            A* implementation with Standley's operator decomposition (OD).
            See AAAI 2010 paper by Trevor Standley on Cooperative Pathfinding.
            </summary>
        </member>
        <member name="M:mapf.A_Star_WithOD.Expand(mapf.WorldState)">
            <summary>
            Expand a given node. This includes:
            - Generating all possible children
            - Inserting them to OPEN
            - Insert the generated nodes to the hashtable of nodes, currently implmented together with the closed list.
            </summary>
        </member>
        <member name="T:mapf.CooperativeAStar">
            <summary>
            Runs David Silver's Cooperative A* (CA*).
            It doesn't find optimal solutions and isn't complete.
            </summary>
        </member>
        <member name="F:mapf.CooperativeAStar.reservationTable">
            <summary>
            The Reservation Table
            </summary>
        </member>
        <member name="F:mapf.CooperativeAStar.parked">
            <summary>
            Maps locations (moves) to the time an agent parked there. From that point on they're
            blocked.
            </summary>
        </member>
        <member name="M:mapf.CooperativeAStar.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="T:mapf.PEA_Star">
            <summary>
            Only keeps generated nodes that have the same f as the parent.
            The parent is then re-inserted with the lowest f from its discarded children
            (Yoshizumi, Miura, and Ishida 2000)
            </summary>
        </member>
        <member name="F:mapf.PEA_Star.nextFvalue">
            <summary>
            The lowest discarded F
            </summary>
        </member>
        <member name="M:mapf.PEA_Star.ProcessGeneratedNode(mapf.WorldState)">
            <summary>
            Adds nodes of target F only
            </summary>
            <param name="currentNode"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.CBS">
            <summary>
            Merges agents if they conflict more times than the given threshold in the CT nodes
            from the root to the current CT nodes only.
            </summary>
        </member>
        <member name="F:mapf.CBS.CONSTRAINTS">
            <summary>
            The key of the constraints list used for each CBS node
            </summary>
        </member>
        <member name="F:mapf.CBS.MUST_CONSTRAINTS">
            <summary>
            The key of the must constraints list used for each CBS node
            </summary>
        </member>
        <member name="F:mapf.CBS.CAT">
            <summary>
            The key of the internal CAT for CBS, used to favor A* nodes that have fewer conflicts with other routes during tie-breaking.
            Also used to indicate that CBS is running.
            </summary>
        </member>
        <member name="F:mapf.CBS.mddCache">
            <summary>
            For each agent, map sets of constraints to MDDs
            </summary>
        </member>
        <member name="F:mapf.CBS.mddNarrownessValuesCache">
            <summary>
            For each agent, map sets of constraints to a dictionary that
            maps each level (timestep) of its mdd to a narrowness degree.
            Non-narrow levels are omitted.
            </summary>
        </member>
        <member name="F:mapf.CBS.closedList">
            <summary>
            Might as well be a HashSet. We don't need to retrieve from it.
            TODO: Consider a closedList for single agent paths under an unordered set of constraints.
                  It would get more hits.
            </summary>
        </member>
        <member name="F:mapf.CBS.solutionDepth">
            <summary>
            The difference between the solution's cost and the f of the root node.
            Notice root.g != 0 in CBS.
            </summary>
        </member>
        <member name="F:mapf.CBS.maxSolutionCost">
            <summary>
            Nodes with a higher F aren't generated. As a result, goal nodes with a higher cost
            won't be found.
            </summary>
        </member>
        <member name="F:mapf.CBS.minSolutionCost">
            <summary>
            Goal Nodes with with a lower cost aren't considered a goal. Used directly by CbsNode.
            </summary>
        </member>
        <member name="P:mapf.CBS.targetF">
            <summary>
            Search is stopped when the minimum F in the open list reaches the target,
            regardless of whether a goal node was found. Note maxSolutionCost stops the search when
            the same F value is exhausted from the open list later.
            </summary>
        </member>
        <member name="P:mapf.CBS.lowLevelGeneratedCap">
            <summary>
            Search is stopped when the low level generated nodes count exceeds the cap
            </summary>
        </member>
        <member name="P:mapf.CBS.milliCap">
            <summary>
            Search is stopped when the millisecond count exceeds the cap
            </summary>
        </member>
        <member name="F:mapf.CBS.topMost">
            <summary>
            Used to know when to clear problem parameters.
            </summary>
        </member>
        <member name="M:mapf.CBS.#ctor(mapf.ICbsSolver,mapf.ICbsSolver,System.Int32,mapf.CBS.BypassStrategy,System.Boolean,mapf.CBS.ConflictChoice,mapf.ILazyHeuristic{mapf.CbsNode},System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="singleAgentSolver"></param>
            <param name="generalSolver"></param>
            <param name="mergeThreshold"></param>
            <param name="bypassStrategy"></param>
            <param name="doMalte"></param>
            <param name="conflictChoice"></param>
            <param name="heuristic">Assumed to be expensive to compute. Used as late as possible</param>
            <param name="disableTieBreakingByMinOpsEstimate"></param>
            <param name="lookaheadMaxExpansions"></param>
            <param name="mergeCausesRestart"></param>
        </member>
        <member name="M:mapf.CBS.Setup(mapf.ProblemInstance,System.Int32,mapf.Run,System.Int32,System.Int32,mapf.MDD)">
            <summary>
            
            </summary>
            <param name="problemInstance"></param>
            <param name="minSolutionTimeStep"></param>
            <param name="runner"></param>
            <param name="minSolutionCost"></param>
            <param name="maxSolutionCost"></param>
            <param name="mdd">Currently ignored. FIXME: Need to convert to array of MDDs to use.</param>
        </member>
        <member name="M:mapf.CBS.SetGlobals">
            <summary>
            
            </summary>
            <returns>Whether this is the top-most CBS</returns>
        </member>
        <member name="M:mapf.CBS.ExpandImpl(mapf.CbsNode,System.Boolean,mapf.CbsNode)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="adopt"></param>
            <param name="children"></param>
            <param name="reinsertParent">If it was only partially expanded</param>
            <param name="adoptBy">If not given, adoption is done by expanded node</param>
            <returns>true if adopted - need to rerun this method, ignoring the returned children from this call, bacause adoption was performed</returns>
        </member>
        <member name="M:mapf.CBS.IcbsExpand(mapf.CbsNode)">
            <summary>
            Supports Prefering cardinal conflicts and BP1 with lookaheadMaxExpansions == 1,
            assumes we choose cardinal conflicts using one of the methods
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:mapf.CBS.MergeExpand(mapf.CbsNode)">
            <summary>
            </summary>
            <param name="node"></param>
            <returns>A ValueTuple with:
            child: null if planning the child's path failed or it was a closed list hit, otherwise - the new child
            closedListHitChildCost: Used to tell if conflict is cardinal, semi-cardinal or
            non-cardinal when the child is a closed list hit.
            </returns>
        </member>
        <member name="M:mapf.CBS.ConstraintExpand(mapf.CbsNode,System.Boolean)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="doLeftChild"></param>
            <returns>
            <returns>A ValueTuple with:
            child: null if planning the child's path failed or it was a closed list hit,
            the parent node if expansion was deferred, or otherwise - the new child.
            closedListHitChildCost: Used to tell if conflict is cardinal, semi-cardinal or
            non-cardinal when the child is a closed list hit.
            </returns>
            </returns>
        </member>
        <member name="T:mapf.MACBS_WholeTreeThreshold">
            <summary>
            Merges agents if they conflict more times than the given threshold in all the CT.
            </summary>
        </member>
        <member name="M:mapf.MACBS_WholeTreeThreshold.Setup(mapf.ProblemInstance,mapf.Run)">
            <summary>
            Assumes agent nums start from 0 and are consecutive.
            </summary>
            <param name="problemInstance"></param>
            <param name="runner"></param>
        </member>
        <member name="T:mapf.CbsHeuristicForAStar">
            <summary>
            Runs a bounded CBS to get an lower estimate of the cost from a given A* node to the goal.
            TODO: This class can actually be generalized to SolverHeuristic and be used as a brute-force estimator.
                  The only CBS things in it are the targetCost, the Debug.Assert that the root costs exactly like SIC's
                  estimate, and the statistics.
            </summary>
        </member>
        <member name="M:mapf.CbsHeuristicForAStar.#ctor(mapf.CBS,mapf.Run,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            </summary>
            <param name="cbs">The underlying CBS to use</param>
            <param name="runner"></param>
            <param name="reportSolution">
            Whether to store the solution found by CBS in the node.
            This should greatly speed up searches.</param>
            <param name="minAboveSic">
            The minimum increment by which to beat SIC's estimate, if possible.
            Larger values would cause each call to the heuristic to take longer, but make it return better estimates.
            </param>
            <param name="validate"></param>
        </member>
        <member name="M:mapf.CbsHeuristicForAStar.h(mapf.WorldState)">
            <summary>
            
            Assumes g of node was already calculated!
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsHeuristicForAStar.h(mapf.WorldState,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Computes a heuristic by running a bounded CBS search from the given node.
            Assumes g of node was already calculated and h isn't zero.
            </summary>
            <param name="s"></param>
            <param name="targetCost">Stop when the target cost is reached</param>
            <param name="sicEstimate">For a debug assertion.</param>
            <param name="lowLevelGeneratedCap">The number of low level nodes to generate</param>
            <param name="milliCap">The process total millisecond count to stop at</param>
            <param name="resume">Whether to resume the last search instead of solving the given node. Assumes the last search was from the same node as the given node.</param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsHeuristicForAStar.Init(mapf.ProblemInstance,System.Collections.Generic.List{System.UInt32})">
            <summary>
            Part of the HeuristicCalculator interface.
            </summary>
            <param name="pi"></param>
            <param name="agentsToConsider">Only passed to the underlying heuristic. TODO: Consider using in h() too.</param>
        </member>
        <member name="M:mapf.CbsHeuristicForAStar.ClearStatistics">
            <summary>
            Clears statistics.
            </summary>
        </member>
        <member name="M:mapf.DyanamicLazyCbsHeuristicForAStar.h(mapf.WorldState,System.Int32,System.Single)">
            <summary>
            Assumes g of node was already calculated.
            </summary>
            <param name="s"></param>
            <param name="targetH"></param>
            <param name="effectiveBranchingFactor"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.DyanamicLazyCbsHeuristicForAStar.h(mapf.WorldState,System.Int32,System.Single,System.Int32,System.Boolean)">
            <summary>
            Assumes g of node was already calculated.
            </summary>
            <param name="s"></param>
            <param name="targetH"></param>
            <param name="effectiveBranchingFactor"></param>
            <param name="millisCap"></param>
            <param name="resume"></param>
            <returns></returns>
        </member>
        <member name="F:mapf.CbsConflict.isVertexConflict">
            <summary>
            If true, conflict is two agents have same dest, from any direction. Otherwise it's an edge conflict.
            </summary>
        </member>
        <member name="M:mapf.ConflictGraph.ApproximateMinimumVertexCover(System.Int32)">
            <summary>
            
            </summary>
            <param name="prevMVC"></param>
            <returns>The size of the 2-approximate minimum vertex cover</returns>
        </member>
        <member name="M:mapf.ConflictGraph.MinimumVertexCover(System.Int32)">
            <summary>
            
            </summary>
            <param name="prevMVC"></param>
            <returns>The size of the minimum vertex cover</returns>
        </member>
        <member name="M:mapf.ConflictGraph.KVertexCover(mapf.ConflictGraph,System.Int32,System.Int32)">
            <summary>
            Return whether there exists a k-vertex (at most) cover solution (an NP-Complete question).
            This algorithm theoretically runs in O(2^(k-1)*2*n), or O(2^k*n). It was described in Parameterized
            Computational Feasibility (Downey and Fellows, 1995).
            The algorithm with the best asymptotic dependence on k was desribed in Improved
            Parameterized Upper Bounds for Vertex Cover (Cheng, Kanj and Xia 2006) and has a runtime of
            O(1.2738^k + kn). Even that algorithm can only find a vertex cover of size up to ~190 in
            reasonable time.
            </summary>
        </member>
        <member name="T:mapf.DisjointSets`1">
            <summary>
            Algorithm from http://en.wikipedia.org/wiki/Disjoint-set_data_structure.
            Operations cost O(Ackerman^-1(n)) time - practically constant. Cost is asymptotically optimal :)
            </summary>
        </member>
        <member name="M:mapf.DisjointSets`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
            Initially all entries are single item sets.
            </summary>
            <param name="entries"></param>
        </member>
        <member name="M:mapf.DisjointSets`1.AddSet(`0)">
            <summary>
            Does nothing if entry is already present.
            Returns whether the entry was really added now.
            </summary>
        </member>
        <member name="M:mapf.DisjointSets`1.IsSingle(`0)">
            <summary>
            Assumes entry is already in the DisjointSets data structure
            </summary>
            <param name="entry"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.DisjointSets`1.CopyUnions(mapf.DisjointSets{`0})">
            <summary>
            Modifies this data structure to also contains all unions from other.
            </summary>
            <param name="other"></param>
            <returns>Whether this object was changed</returns>
        </member>
        <member name="M:mapf.DisjointSets`1.Find(mapf.DisjointSetItem)">
            <summary>
            Finds the representative of the item's set
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.DisjointSets`1.Union(`0,`0)">
            <summary>
            Doesn't assume x, y already in the data structure.
            Returns whether they were really only united now.
            </summary>
            <param name="entryA"></param>
            <param name="entryB"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.DisjointSets`1.AreUnited(`0,`0)">
            <summary>
            Assumes entries are already in the DisjointSets data structure
            </summary>
            <param name="entryA"></param>
            <param name="entryB"></param>
            <returns></returns>
        </member>
        <member name="P:mapf.IHeuristicSearchNode.hBonus">
            <summary>
            Used to mark that heuristic estimate was improved already
            </summary>
        </member>
        <member name="M:mapf.IHeuristicSearchNode.GetTargetH(System.Int32)">
            <summary>
            Returns the h needed to set (raise) the node's f to the given value
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.IterativeDeepeningCBS">
            <summary>
            Is the CBS open list ever large enough to warrant this?
            Consider foregoing this implementation. It needs maintainence anyway.
            </summary>
        </member>
        <member name="F:mapf.MddPruningHeuristicForCbs.cache">
            <summary>
            Maps a pair of agents and their costs to whether there's a solution with those costs
            </summary>
        </member>
        <member name="M:mapf.MddPruningHeuristicForCbs.h(mapf.CbsNode)">
            <summary>
            Returns 0 if the conflict is solvable with the current costs, 1 otherwise. If unsure, returns 0;
            Currently avoiding building a k-agent MDD.
            TODO: This became largely irrelevant after we've discovered cardinal conflicts, but
            now that we're always building all MDDs, it might be worth it to try to sync the MDDs
            for nodes with no cardinal conflicts. We might find they're still unsolvable
            with the current costs.
            </summary>
            <param name="s"></param>
            <param name="ignoreConstraints">
            Ignore constraints. This allows the results for the given costs to be used elsewhere in
            the CBS tree, but can cause under-estimates and make building the MDD a little slower.
            </param>
            <returns>
            If after syncing and pruning the MDDs at the current costs for the two conflicting agents
            the whole MDD was pruned, indicating these agents can't be solved at the current cost,
            returns 1. Else returns 0
            </returns>
        </member>
        <member name="M:mapf.MddPruningHeuristicForCbs.h(mapf.CbsNode,System.Int32)">
            <summary>
            Lazy version
            </summary>
            <param name="s"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.ApproximateMvcHeuristicForCbs">
            <summary>
            Uses the half the size of the 2-approximation of the MVC of the cardinal conflict graph as a
            heuristic. Builds fewer MDDs when the lazy method is used, and, of course, runs faster than
            brute-forcing the MVC.
            </summary>
        </member>
        <member name="M:mapf.ApproximateMvcHeuristicForCbs.h(mapf.CbsNode)">
            <summary>
            Compute h value with an approximate minimum vertex cover solver.
            This heuristic is bounded by the maximal matching of the graph.
            Assumes the s.cbs.mergeThreshold is -1.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.ApproximateMvcHeuristicForCbs.h(mapf.CbsNode,System.Int32)">
            <summary>
            Lazy version - only builds MDDs if it has to, and only computes the heuristic up to the
            target value.
            </summary>
            <param name="s"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.MvcHeuristicForCbs.h(mapf.CbsNode)">
            <summary>
            Compute h value with a minimum vertex cover solver.
            Assumes the s.cbs.mergeThreshold is -1.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.MvcHeuristicForCbs.h(mapf.CbsNode,System.Int32)">
            <summary>
            Lazy version
            </summary>
            <param name="s"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:mapf.ConflictAvoidanceTable.Keys">
            <summary>
            Gets an enumerable collection that contains the keys in the read-only dictionary
            </summary>
            <returns>An enumerable collection that contains the keys in the read-only dictionary</returns>
        </member>
        <member name="P:mapf.ConflictAvoidanceTable.Values">
            <summary>
            Gets an enumerable collection that contains the values in the read-only dictionary
            </summary>
            <returns>An enumerable collection that contains the values in the read-only dictionary</returns>
        </member>
        <member name="P:mapf.ConflictAvoidanceTable.Item(mapf.TimedMove)">
            <summary>
            Gets the element that has the specified key in the read-only dictionary.
            </summary>
            <param name="key">The key to locate</param>
            <returns>The element that has the specified key in the read-only dictionary</returns>
            <exception cref="T:System.ArgumentNullException">key is null</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and key is not found</exception>
        </member>
        <member name="M:mapf.ConflictAvoidanceTable.ContainsKey(mapf.TimedMove)">
            <summary>
            Determines whether the read-only dictionary contains an element that has
             the specified key.
            </summary>
            <param name="key">The key to locate.</param>
            <returns>true if the read-only dictionary contains an element that has the specified key;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">key is null</exception>
        </member>
        <member name="M:mapf.ConflictAvoidanceTable.TryGetValue(mapf.TimedMove,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Gets the value that is associated with the specified key.
            </summary>
            <param name="key">The key to locate</param>
            <param name="value">
            When this method returns, the value associated with the specified key, if
            the key is found; otherwise, the default value for the type of the value
            parameter. This parameter is passed uninitialized.
            </param>
            <exception cref="T:System.ArgumentNullException">key is null</exception>
            <returns>
            true if the object that implements the System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;
            interface contains an element that has the specified key; otherwise, false.
            </returns>
        </member>
        <member name="T:mapf.Dictionary_U`2">
            <summary>
            This class represents a union of Dictionaries, which each map <typeparamref name="K"/>
            to a List of <typeparamref name="V"/>.
            It is similar to Python's collections.ChainMap, but 1) read-only, 2) a combined list of V
            elements is returned instead of just the first match.
            </summary>
        </member>
        <member name="P:mapf.Dictionary_U`2.Keys">
            <summary>
            Gets an enumerable collection that contains the keys in the read-only dictionary.
            Warning: May contain duplicates if multiple inner dicts have the same key.
            </summary>
            <returns>An enumerable collection that contains the keys in the read-only dictionary.</returns>
        </member>
        <member name="P:mapf.Dictionary_U`2.Values">
            <summary>
            Gets an enumerable collection that contains the values in the read-only dictionary.
            </summary>
            <returns>
            An enumerable collection that contains the values in the read-only dictionary.
            </returns>
        </member>
        <member name="P:mapf.Dictionary_U`2.Item(`0)">
            <summary>
            Gets a combined list of the values mapped to the specified key in the combined dictionaries.
            </summary>
            <param name="key">The key to locate.</param>
            <returns>A combined list of the values mapped to the specified key in combined dictionaries.</returns>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">key is not found.</exception>
        </member>
        <member name="M:mapf.Dictionary_U`2.TryGetValue(`0,System.Collections.Generic.List{`1}@)">
            <summary>
            Gets a combined list of values mapped to the specified key in the combined dictionaries, or null if none
            are found.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.Dictionary_U`2.ContainsKey(`0)">
            <summary>
            Returns whether the specified key exists in any of the combined dictionaries
            </summary>
            <param name="key">The key to look for</param>
            <returns></returns>
        </member>
        <member name="M:mapf.Dictionary_U`2.Clear">
            <summary>
            Remove all dictionaries from the union
            </summary>
        </member>
        <member name="M:mapf.Dictionary_U`2.Join(System.Collections.Generic.IReadOnlyDictionary{`0,System.Collections.Generic.List{`1}})">
            <summary>
            Add a dictionary to the union
            </summary>
            <param name="other">the dictionary to add</param>
        </member>
        <member name="M:mapf.Dictionary_U`2.Separate(System.Collections.Generic.IReadOnlyDictionary{`0,System.Collections.Generic.List{`1}})">
            <summary>
            Remove a dictionary from the union
            </summary>
            <param name="other">the dictionary to add</param>
        </member>
        <member name="M:mapf.Dictionary_U`2.Print">
            <summary>
            Not used.
            </summary>
        </member>
        <member name="P:mapf.Dictionary_U`2.Count">
            <summary>
            Gets the number of keys in the Dictionary. 
            </summary>
        </member>
        <member name="M:mapf.IStatisticsCsvWriter.OutputStatisticsHeader(System.IO.TextWriter)">
            <summary>
            Prints header of statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.IStatisticsCsvWriter.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output.
            </summary>
        </member>
        <member name="P:mapf.IStatisticsCsvWriter.NumStatsColumns">
            <summary>
            To fill out them out when an algorithm isn't run
            </summary>
        </member>
        <member name="M:mapf.IStatisticsCsvWriter.ClearStatistics">
            <summary>
            Clears statistics.
            </summary>
        </member>
        <member name="T:mapf.OpenList`1">
            <summary>
            Supporting O(1) insertion and removal of items that compare equal to the top of the heap.
            TODO: Compare against a bucketed implementation where all equal costs are bucketed in a queue,
                  even though it might not respect all tie-breaking (but still prioritizes goal nodes).
            </summary>
        </member>
        <member name="M:mapf.OpenList`1.Remove(`0)">
            <summary>
            Uses Equality check only for removing from the queue.
            Might cost O(n) if all items are in the queue and not the heap.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.OpenList`1.Contains(`0)">
            <summary>
            Assumes item was added to the open list in the past
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.DynamicLazyOpenList`1">
            <summary>
            This open list invokes an expensive-to-compute heuristic on items before they're removed,
            potentially pushing them back into itself if their F value increased above the next item in
            the list.
            The heuristic is given the "target value" - the minimum estimate that would cause an item to
            be pushed back, and is allowed to stop once this estimate was reached.
            </summary>
            <typeparam name="Item"></typeparam>
        </member>
        <member name="M:mapf.RandomChoiceOfHeuristic`1.#ctor(mapf.IHeuristicCalculator{`0},mapf.IHeuristicCalculator{`0},System.Double,System.Int32)">
            <summary>
            
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <param name="p"></param>
            <param name="seed"></param>
        </member>
        <member name="M:mapf.HashSet_U`1.Clear">
            <summary>
            Hardly used.
            </summary>
        </member>
        <member name="M:mapf.HashSet_U`1.Print">
            <summary>
            Not used.
            </summary>
        </member>
        <member name="P:mapf.HashSet_U`1.Count">
            <summary>
            Gets the number of values in the HashSet. 
            </summary>
        </member>
        <member name="T:mapf.IBinaryHeapItem">
            <summary>
            represents items that are stored in the binary heap
            </summary>
        </member>
        <member name="M:mapf.IBinaryHeapItem.GetIndexInHeap">
            <summary>
            The index of the item in the binary heap
            </summary>
        </member>
        <member name="T:mapf.BinaryHeap`1">
            <summary>
            A binary heap, useful for sorting data and priority queues.
            </summary>
        </member>
        <member name="M:mapf.BinaryHeap`1.#ctor">
            <summary>
            Creates a new binary heap.
            </summary>
        </member>
        <member name="M:mapf.BinaryHeap`1.#ctor(System.Int32)">
            <summary>
            Creates a new binary heap with the specified initial capacity.
            </summary>
        </member>
        <member name="M:mapf.BinaryHeap`1.#ctor(`0[],System.Int32)">
            <summary>
            Creates a new binary heap from the given array.
            </summary>
        </member>
        <member name="M:mapf.BinaryHeap`1.#ctor(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>
            Creates a new binary heap from the given collection.
            </summary>
        </member>
        <member name="P:mapf.BinaryHeap`1.Count">
            <summary>
            Gets the number of values in the heap. 
            </summary>
        </member>
        <member name="P:mapf.BinaryHeap`1.Capacity">
            <summary>
            Gets or sets the capacity of the heap.
            Can only set it to values larger than the current capacity.
            </summary>
        </member>
        <member name="M:mapf.BinaryHeap`1.Peek">
            <summary>
            Gets the first value in the heap without removing it.
            </summary>
            <returns>The lowest value of type TValue.</returns>
        </member>
        <member name="M:mapf.BinaryHeap`1.Clear">
            <summary>
            Removes all items from the heap.
            </summary>
        </member>
        <member name="M:mapf.BinaryHeap`1.Add(`0)">
            <summary>
            Adds a key and value to the heap.
            </summary>
            <param name="item">The item to add to the heap.</param>
        </member>
        <member name="M:mapf.BinaryHeap`1.Remove">
            <summary>
            Removes and returns the first item in the heap.
            </summary>
            <returns>The next item in the heap.</returns>
        </member>
        <member name="M:mapf.BinaryHeap`1.Parent(System.Int32)">
            <summary>
            helper function that calculates the parent of a node
            </summary>
            <param name="index"></param>
            <returns>-1 if there's no parent (index==0)</returns>
        </member>
        <member name="M:mapf.BinaryHeap`1.Child1(System.Int32)">
            <summary>
            helper function that calculates the first child of a node
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.BinaryHeap`1.Child2(System.Int32)">
            <summary>
            helper function that calculates the second child of a node
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.BinaryHeap`1.Copy">
            <summary>
            Creates a new instance of an identical binary heap.
            </summary>
            <returns>A BinaryHeap.</returns>
        </member>
        <member name="M:mapf.BinaryHeap`1.Contains(`0)">
            <summary>
            Checks to see if the binary heap contains the specified item.
            Uses CompareTo, not the item's binary heap index.
            First call runs in O(nlogn) time. Next calls are O(logn).
            </summary>
            <param name="item">The item to search the binary heap for.</param>
            <returns>A boolean, true if binary heap contains item.</returns>
        </member>
        <member name="M:mapf.BinaryHeap`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the binary heap to an array at the specified index.
            </summary>
            <param name="array">One dimensional array that is the destination of the copied elements.</param>
            <param name="arrayIndex">The zero-based index at which copying begins.</param>
        </member>
        <member name="P:mapf.BinaryHeap`1.IsReadOnly">
            <summary>
            Returns whether or not the binary heap is readonly.
            </summary>
        </member>
        <member name="M:mapf.BinaryHeap`1.Remove(`0)">
            <summary>
            Removes an item from the binary heap. 
            Assumes item is or was in the heap. Doesn't use Equality checks.
            This will not remove duplicates.
            TODO: Change into Remove(int binaryHeapIndex)!
            </summary>
            <param name="item">The item to be removed.</param>
            <returns>Boolean true if the item was removed.</returns>
        </member>
        <member name="F:mapf.AdditivePDBs.excludedAgents">
            <summary>
            The set of agents that are not covered by this set of pattern
            databases. This information is not used by this class or any of its
            related classes, but is simply precomputed as useful information for
            the caller (for example, if the caller wanted to add to our
            heuristic estimate).
            </summary>
        </member>
        <member name="M:mapf.AdditivePDBs.build(mapf.ProblemInstance,mapf.WorldState)">
            <summary>
            Determines how many additive pattern databases to build and divides
            the agents among them, possibly leaving some agents out.
            </summary>
            <param name="pi">the problem instance to use</param>
            <param name="s">The root of the search tree. This is also expected
            to have context parameters such as agents' goal states.</param>
        </member>
        <member name="M:mapf.AdditivePDBs.Init(mapf.ProblemInstance,System.Collections.Generic.List{System.UInt32})">
            <summary>
            Initializes the pattern database by storing references to the
            problem instance and also the subset of agents that the pattern
            database pertains to.
            </summary>
            <param name="pi">The problem instance.</param>
            <param name="vAgents">The agents that the pattern database should keep track of.</param>
        </member>
        <member name="M:mapf.AdditivePDBs.h(mapf.WorldState)">
            <summary>
            Simply returns the sum of each of the additive pattern database 
            heuristic estimates on the given state.
            </summary>
            <param name="s">The state.</param>
            <returns>The admissible heuristic value for the additive pattern
            databases.</returns>
        </member>
        <member name="M:mapf.AdditivePDBs.OutputStatisticsHeader(System.IO.TextWriter)">
            <summary>
            Prints header of statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.AdditivePDBs.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output.
            </summary>
        </member>
        <member name="M:mapf.AdditivePDBs.ClearStatistics">
            <summary>
            Clears statistics.
            </summary>
        </member>
        <member name="T:mapf.IndependenceDetectionConflict">
            <summary>
            This class represents a conflict between two groups of agents in Trevor Standley's
            Indepedence Detection algorithm.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.minimumVertexCover">
            <summary>
            The size of the minimum vertex cover of the node's cardinal conflict graph.
            Needs to be saved separately from h to allow speeding up the computation of the heuristic
            of the children.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.minOpsToSolve">
            <summary>
            A lower estimate of the number of operations (replanning or merging) needed to solve the node.
            Used for tie-breaking.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.countsOfInternalAgentsThatConflict">
            <summary>
            For each agent in the problem instance, saves the number of agents from the problem instance that it conflicts with.
            Used for choosing the next conflict to resolve by replanning/merging/shuffling, and for tie-breaking.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.totalExternalAgentsThatConflict">
            <summary>
            Counts the number of external agents this node conflicts with.
            Used for tie-breaking.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.totalConflictsWithExternalAgents">
            <summary>
            Used for tie-breaking.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.conflictCountsPerAgent">
            <summary>
            For each agent in the problem instance, maps agent _nums_ it conflicts with, internal or external,
            to the number of conflicts betweem them.
            Used for book-keeping to maintain countsOfInternalAgentsThatConflict,
            totalExternalAgentsThatConflict and minOpsToSolve, and other counts.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.conflictTimesPerAgent">
            <summary>
            For each agent in the problem instance, maps agent _nums_ of agents it collides with to the time of their first collision.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.mustConstraint">
            <summary>
            Forcing an agent to be at a certain place at a certain time
            </summary>
        </member>
        <member name="F:mapf.CbsNode.agentAExpansion">
            <summary>
            For partial expansion
            </summary>
        </member>
        <member name="F:mapf.CbsNode.agentBExpansion">
            <summary>
            For partial expansion
            </summary>
        </member>
        <member name="F:mapf.CbsNode.totalInternalAgentsThatConflict">
            <summary>
            For tie-breaking
            </summary>
        </member>
        <member name="F:mapf.CbsNode.largerConflictingGroupSize">
            <summary>
            For tie-breaking
            </summary>
        </member>
        <member name="F:mapf.CbsNode.totalConflictsBetweenInternalAgents">
            <summary>
            For tie-breaking
            </summary>
        </member>
        <member name="F:mapf.CbsNode.mddNarrownessValues">
            <summary>
            For each agent, map each level (timestep) of its mdd to a narrowness degree.
            Non-narrow levels are omitted.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.mdds">
            <summary>
            FIXME: We're currently saving both the MDDs and their much smaller narrowness values in
            order to have a fair comparison with the past
            </summary>
        </member>
        <member name="M:mapf.CbsNode.#ctor(mapf.CbsNode,mapf.CbsConstraint,System.Int32)">
            <summary>
            Child from branch action constructor
            </summary>
            <param name="parent"></param>
            <param name="newConstraint"></param>
            <param name="agentToReplan"></param>
        </member>
        <member name="M:mapf.CbsNode.#ctor(mapf.CbsNode,System.Int32,System.Int32)">
            <summary>
            Child from merge action constructor. FIXME: Code dup with previous constructor.
            </summary>
            <param name="parent"></param>
            <param name="mergeGroupA"></param>
            <param name="mergeGroupB"></param>
        </member>
        <member name="P:mapf.CbsNode.f">
            <summary>
            Total cost + heuristic estimate
            </summary>
        </member>
        <member name="M:mapf.CbsNode.Solve(System.Int32)">
            <summary>
            Solves the entire node - finds a plan for every agent group.
            Since this method is only called for the root of the constraint tree, every agent is in its own group.
            </summary>
            <param name="depthToReplan"></param>
            <returns>Whether solving was successful. Solving fails if a timeout occurs.</returns>
        </member>
        <member name="M:mapf.CbsNode.Replan(System.Int32,System.Int32,System.Collections.Generic.List{mapf.AgentState},System.Int32,System.Int32,System.Int32)">
            <summary>
            Replan for a given agent (when constraints for that agent have changed, or its group was enlarged).
            </summary>
            <param name="agentToReplan"></param>
            <param name="minPathTimeStep"></param>
            <param name="subGroup">If given, assume CAT is already populated and use this subGroup</param>
            <param name="maxPlanSizeOfOtherAgents">
            Internal optimization parameter indicating the max timestep to check for in-goal conflicts.
            If subGroup is given, this value is used instead of computing it.
            </param>
            <param name="minPathCost"></param>
            <param name="maxPathCost"></param>
            <returns>Whether a path was successfully found</returns>
        </member>
        <member name="M:mapf.CbsNode.UpdateAtGoalConflictCounts(System.Int32,System.Int32,System.Collections.Generic.IReadOnlyDictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Update conflict counts according to what happens after the plan finishes -
            needed if the plan is shorter than one of the previous plans and collides
            with it while at the goal.
            It's cheaper to do it this way than to force the solver the go more deeply.
            The conflict counts are saved at the group's representative.
            </summary>
        </member>
        <member name="M:mapf.CbsNode.CalcMinOpsToSolve">
             <summary>
             Calculates the minimum number of replans to solve, and from it the minimum number of replans or merges to solve.
             
             A replan can resolve all of the agent's conflicts by luck, even if it was only targeting a single conflict.
            
             To calculate the minimum number of replans to solve, 
             what we want is the size of the minimum vertex cover of the conflict graph.
             Sadly, it's an NP-hard problem. Its decision variant is NP-complete.
             Happily, it has a 2-approximation: Just choose both endpoints of each uncovered edge
             repeatedly until no uncovered edges are left. So we can just take half the count from
             that approximation.
             
             TODO: the graph is small enough that we can try to solve optimally.
             
             Notice a merge is like two replans in one, so we might need to take ceil(num_replans/2).
             Luckily, in MA-CBS which considers only conflicts in the same CT branch,
             a merge is only possible once every B+1 depth steps,
             because we only count selected conflicts (they're guaranteed to be unequal),
             so we can cap the number of possible merges and subtract less.
             
             In Cbs_GlobalConflicts, we could use the global table to discount some merges.
             </summary>
        </member>
        <member name="M:mapf.CbsNode.CountConflicts">
            <summary>
            Populates the totalInternalAgentsThatConflict, totalConflictsBetweenInternalAgents,
            totalConflictsWithExternalAgents, and countsOfInternalAgentsThatConflict counters
            from the conflictCountsPerAgent values that are created while solving or replanning.
            Those counters are used for tie-breaking.
            </summary>
        </member>
        <member name="F:mapf.CbsNode.nextConflicts">
            <summary>
            Used to preserve state of conflict iteration.
            </summary>
        </member>
        <member name="M:mapf.CbsNode.ClearConflictChoiceData">
            <summary>
            The iterator holds the state of the generator, with all the different queues etc - a lot of memory.
            We also clear the MDD narrowness values that were computed - if no child uses them, they'll be garbage-collected.
            </summary>
        </member>
        <member name="M:mapf.CbsNode.ChooseNextPotentiallyCardinalConflicts">
            <summary>
            Use after expanding a node and finding the conflict wasn't cardinal
            </summary>
            <returns>Whether we found a new potentially cardinal conflict to work on</returns>
        </member>
        <member name="M:mapf.CbsNode.ChooseNextConflict">
            <summary>
            
            </summary>
            <returns>Whether another conflict was found</returns>
        </member>
        <member name="M:mapf.CbsNode.ChooseConflict">
            <summary>
            Chooses an internal conflict to work on.
            Resets conflicts iteration if it's used.
            </summary>
        </member>
        <member name="M:mapf.CbsNode.GetConflictsNoOrder">
            <summary>
            No special ordering.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetConflictsExhaustivelySearchingForCardinalsGreedily">
            <summary>
            Assumes this.mergeThreshold == -1.
            Builds MDDs for all agents.
            Not currently used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.buildAllMDDs">
            <summary>
            Currently only used by the above unused function
            </summary>
        </member>
        <member name="M:mapf.CbsNode.GetConflictsExhaustivelySearchingForCardinalsLazily">
            <summary>
            Assumes this.mergeThreshold == -1.
            Builds MDDs as necessary until a cardinal conflict is found.
            Also sets h to 1 if a cardinal conflict is found.
            Not currently used.
            </summary>
            <returns></returns>
        </member>
        <member name="F:mapf.CbsNode.nextConflictCouldBeCardinal">
            <summary>
            CBS may use this to decide whether to give up the current conflict and check the next one.
            </summary>
        </member>
        <member name="M:mapf.CbsNode.GetConflictsCardinalFirstUsingMdd">
            <summary>
            Returns all conflicts, cardinal first, then possibly cardinal, then semi cardinal,
            then possibly semi cardinal, and finally non-cardinal, building MDDs as necessary.
            Trying to build MDDs as late as possible.
            
            TODO: Consider turning all queues into priority queues that prefer smaller agents, smaller degree etc.
            TODO: Find a better data structure to support faster deletion from queues.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetConflictsCardinalFirstUsingMddInternal">
            <summary>
            Builds MDDs as lazily as possible.
            </summary>
            <returns>
            Iterates over conflicts in the following order: certainly cardinal (by 2 MDDs),
            possibly cardinal (by 1 MDD, the other agent is a meta-agent),
            possibly cardinal (2 meta-agents),
            semi-cadinal (by 2 MDDs), possibly semi-cardinal (by 1 mdd, the other agent is a meta-agent),
            non-cardinal
            </returns>
        </member>
        <member name="M:mapf.CbsNode.FindConflict(System.Int32,System.Int32,System.Int32,System.Collections.Generic.ISet{System.Int32}[])">
            <summary>
            Assuming the groups conflict, return their conflict.
            </summary>
            <param name="aConflictingGroupMemberIndex"></param>
            <param name="bConflictingGroupMemberIndex"></param>
            <param name="time"></param>
            <param name="groups"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.FindConflicting(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Collections.Generic.ISet{System.Int32}[])">
            <summary>
            Assuming the groups conflict, find the specific agents that conflict.
            Also sets largerConflictingGroupSize.
            </summary>
            <param name="aConflictingGroupMemberIndex"></param>
            <param name="bConflictingGroupMemberIndex"></param>
            <param name="time"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="groups"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.CopyAppropriateMddFromParent(System.Int32)">
            <summary>
            Copy the MDD down the CT branch from an ancestor with an MDD of the same cost.
            Delete nodes from it as necessary.
            </summary>
            <returns>True if an appropriate MDD was found and copied,
            or if an MDD of the same cost was adapted</returns>
        </member>
        <member name="M:mapf.CbsNode.buildMddForAgentWithItsCurrentCost(System.Int32)">
            <summary>
            Builds an MDD for the specified agent with its current cost
            </summary>
            <param name="agentIndex"></param>
            <returns>Whether an MDD was built</returns>
        </member>
        <member name="M:mapf.CbsNode.GetDetailsOfConflictOfMostConflictingSmallestAgents">
             <summary>
             Chooses the first agent to be the one that maximizes the number of agents it conflicts with internally divided by 2^(group_size-1).
             Then chooses an agent among the agents it conflicts with using the same formula.
             Then chooses their first conflict.
            
             Choosing the agent that conflicts the most is a greedy strategy.
             Had replanning promised to resolve all conflicts, it would've been better to choose according to the minimum vertex cover.
             
             Assumes all agents are initially on the same timestep (no OD).
             
             TODO: Prefer conflicts where one of the conflicting agents is at their goal, to reduce the danger of task blow-up
             by enabling partial expansion. On the other hand, partial expansion is only possible in basic CBS.
             </summary>
        </member>
        <member name="M:mapf.CbsNode.AdoptSolutionOf(mapf.CbsNode)">
            <summary>
            Adopt everything but the new constraint, basically.
            
            Notice that to correctly adopt a merge child, adopting its new agentsGroupAssignment is necessary.
            Otherwise its conflicts counts, SinglePlan.agentNum and conflict choice would be incompatible.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:mapf.CbsNode.GetHashCode">
            <summary>
            Uses the group assignments and the constraints (ignoring their order).
            Irrelevant constraints stemming from conflicts between merged agents are ignored.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.Equals(System.Object)">
            <summary>
            Checks the group assignment and the constraints
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.Clear">
            <summary>
            Worth doing because the node may always be in the closed list
            </summary>
        </member>
        <member name="M:mapf.CbsNode.GetLastConstraint">
            <summary>
            Not used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetConstraintsOrdered">
            <summary>
            For printing
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetIndexInHeap">
            <summary>
            IBinaryHeapItem implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.SetIndexInHeap(System.Int32)">
            <summary>
            IBinaryHeapItem implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.ShouldMerge(System.Int32)">
            <summary>
            Check if the agent groups that participate in the conflict of this node pass the merge threshold.
            </summary>
            <param name="mergeThreshold"></param>
            <returns>Whether to merge.</returns>
        </member>
        <member name="M:mapf.CbsNode.ShouldMerge(System.Int32,System.Int32[][])">
            <summary>
            Check if the agent groups that participate in the conflict of this node pass the merge threshold,
            using the given conflict counts.
            </summary>
            <param name="mergeThreshold"></param>
            <param name="globalConflictCounter"></param>
            <returns>Whether to merge.</returns>
        </member>
        <member name="M:mapf.CbsNode.GetGroup(System.Int32)">
            <summary>
            Returns a list of indices of agents in the group
            </summary>
            <param name="agentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetGroupCost(System.Int32)">
            <summary>
            Get the combined cost for the group, either for the sum-of-costs or makespan variant.
            </summary>
            <param name="groupNumber"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetGroupSize(System.Int32)">
            <summary>
            A bit cheaper than GetGroup(n).Count. Still O(n).
            </summary>
            <param name="agentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetGroupSizes">
            <summary>
            In O(n)
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.GetGroups">
            <summary>
            In O(n)
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.MergeGroups(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Updates the agentsGroupAssignment and the conflictCountsPerAgent. Warning: changes the hash!
            </summary>
            <param name="a">Index of first group representative</param>
            <param name="b">Index of second group representative</param>
            <param name="fixCounts"></param>
        </member>
        <member name="M:mapf.CbsNode.PathLength(System.Int32)">
            <summary>
            NOT the cost, just the length - 1.
            </summary>
            <param name="agent"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsNode.Replan3b(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            For CBS IDA* only.
            TODO: Consider inheriting from CbsNode and overriding the Replan method instead.
            </summary>
            <param name="agentToReplan"></param>
            <param name="depthToReplan"></param>
            <param name="minPathCost"></param>
            <returns>Whether a path was successfully found</returns>
        </member>
        <member name="M:mapf.CbsNode.DoesAgentHaveNoOtherOption(System.Int32,System.Int32,System.Int32,System.Collections.Generic.ISet{System.Int32}[])">
            <summary>
            Assumes agents conflict at the given time, and an MDD has been built for the agent
            </summary>
            <param name="agentIndex"></param>
            <param name="conflictTime"></param>
            <param name="conflictingAgentIndex"></param>
            <param name="groups"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.AgentToCheckForCardinalConflicts">
            <summary>
            Because the default tuple comparison compares the first element only :(.
            </summary>
        </member>
        <member name="M:mapf.AgentToCheckForCardinalConflicts.GetIndexInHeap">
            <summary>
            IBinaryHeapItem implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.AgentToCheckForCardinalConflicts.SetIndexInHeap(System.Int32)">
            <summary>
            IBinaryHeapItem implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsConstraint.Equals(System.Object)">
            <summary>
            Checks that the agentNum is equal, and compares the move.
            If one of the constraints is a query, an instance only created and used to quickly search for a move in a set of constraints,
            the direction is ignored if the other constraint is a vertex constraint.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsConstraint.GetHashCode">
            <summary>
            Uses the move and the agents.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.CbsConstraint.Allows(mapf.CbsConstraint)">
            <summary>
            Kind of the opposite of Equals: checks that the moves are unequal or that not one of the other's agents appears in this.agents.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.MDD">
            <summary>
            A compact representation of all the paths to the goal of a given agent that are of a given cost and length
            </summary>
        </member>
        <member name="M:mapf.MDD.#ctor(System.Int32,System.Int32,mapf.Move,System.Int32,System.Int32,System.Int32,mapf.ProblemInstance,System.Boolean,System.Boolean)">
            <summary>
            Builds an MDD by first performing a BFS from start_pos to the agent's goal,
            then deleting all nodes which don't lead to the goal at the given cost.
            </summary>
            <param name="mddNum"></param>
            <param name="agentNum"></param>
            <param name="start_pos"></param>
            <param name="cost">The MDD must be of this cost</param>
            <param name="numOfLevels">
            The MDD must be of this number of levels, not counting level zero.
            If higher than cost, the extra levels will be WAITs at the goal.
            </param>
            <param name="numOfAgents">Used for initializng coexistence lists</param>
            <param name="instance"></param>
            <param name="ignoreConstraints"></param>
            <param name="supportPruning"></param>
        </member>
        <member name="F:mapf.MDD.queryConstraint">
            <summary>
            Just an optimization
            </summary>
        </member>
        <member name="M:mapf.MDD.GetAllChildren(mapf.MDDNode,System.Int32,System.Int32,mapf.HashSet_U{mapf.CbsConstraint},System.Collections.Generic.Dictionary{System.Int32,mapf.TimedMove}[])">
            <summary>
            Returns all the children of a given MDD node that have a heuristic estimate that is not larger than the given heuristic bound.
            </summary>
            <param name="parent"></param>
            <param name="heuristicBound">The heuristic estimate of the returned children must be lower than or equal to the bound</param>
            <param name="numOfAgents">The number of agents in the MDD node</param>
            <param name="constraints"></param>
            <param name="mustConstraints"></param>
            <returns>A list of relevant MDD nodes</returns>
        </member>
        <member name="M:mapf.MDD.SyncMDDs(mapf.MDD,System.Boolean)">
            <summary>
            Match and prune MDD according to another MDD.
            </summary>
            <param name="other"></param>
            <param name="checkTriples">If true, use the "3E" method.</param>
            <returns>How much pruning was done, and by how much the matchCounter should be incremented</returns>
        </member>
        <member name="M:mapf.MDDNode.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.MDDNode.IsCoexistingWithOtherMDDs(mapf.MDDNode,System.Int32)">
            <summary>
            Checks if given MDD node coexists with all nodes from earlier checked MDDs that were
            previously found to coexist with this node.
            Assumes before MDDs i,j are checked for coexistence, all MDDs k such that i &lt; k &lt; j
            were checked.
            Assumes this MDD was built with pruning support.
            </summary>
            <param name="toCheck"></param>
            <param name="otherAgentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.MDDNode.GetHashCode">
            <summary>
            Only uses the move
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.MDDNode.Equals(System.Object)">
            <summary>
            Only uses the move
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.IHeuristicCalculator`1.h(`0)">
            <summary>Returns the heuristic estimate.</summary>
            <param name="s">The current state.</param>
        </member>
        <member name="M:mapf.IHeuristicCalculator`1.Init(mapf.ProblemInstance,System.Collections.Generic.List{System.UInt32})">
            <summary>
            Initializes the pattern database by storing references to the
            problem instance and also the subset of agents that the pattern
            database pertains to.
            </summary>
            <param name="pi">The problem instance.</param>
            <param name="agentsToConsider">The agents that the heuristic should keep track of.</param>
        </member>
        <member name="M:mapf.IHeuristicCalculator`1.GetName">
            <summary>
            Return the name of the heuristic, useful for outputing results.
            This is needed because ToString() is provided by the "object" class so it can't be used
            to force this behavior to be implemented;
            </summary>
            <returns>The name of the solver</returns>
        </member>
        <member name="M:mapf.ILazyHeuristic`1.h(`0,System.Int32)">
            <summary>
            Returns the heuristic estimate. Stops estimation once the target estimate is reached.
            </summary>
            <param name="s">The current state.</param>
            <param name="target">The lowest target estimate to return, if possible.</param>
        </member>
        <member name="M:mapf.IBoundedLazyHeuristic`1.h(`0,System.Int32,System.Single)">
            <summary>
            Returns the heuristic estimate. Stops estimation once the target estimate is reached.
            Used when a low level generated nodes cap is needed.
            </summary>
            <param name="s">The current state.</param>
            <param name="target">The lowest target estimate to return, if possible.</param>
            <param name="effectiveBranchingFactor">The branching factor so far of the A* search we're serving.</param>
        </member>
        <member name="M:mapf.IBoundedLazyHeuristic`1.h(`0,System.Int32,System.Single,System.Int32,System.Boolean)">
            <summary>Returns the heuristic estimate. Used when a time cap is needed.</summary>
            <param name="s">The current state.</param>
            <param name="target">The lowest target estimate to return, if possible.</param>
            <param name="effectiveBranchingFactor">Ignored. Kept only to make the number of parameters different from the previous method.</param>
            <param name="millisCap">Stop the search when the process' total millisecond count reaches the cap.</param>
            <param name="resume">Whether to resume the last search. Assumes last search was from the same node</param>
        </member>
        <member name="F:mapf.Constants.NO_SOLUTION_COST">
            <summary>
            The cost that is set to the algorithms when all the states have been expanded and no goal was found 
            </summary>
        </member>
        <member name="F:mapf.Constants.TIMEOUT_COST">
            <summary>
            The cost that is set to the algorithms when they are halted due to out of time 
            </summary>
        </member>
        <member name="F:mapf.Constants.MAX_MEMORY_COST">
            <summary>
            The cost that is set to the algorithms when they are halted due to out of memory
            </summary>
        </member>
        <member name="F:mapf.Constants.GENERATED_PER_PRINT">
            <summary>
            The number of generated nodes after which a debug print will be given
            </summary>
        </member>
        <member name="F:mapf.Constants.PRIMES_FOR_HASHING">
            <summary>
            Prime numbers for hashing
            </summary>
        </member>
        <member name="F:mapf.Constants.MAX_FAIL_COUNT">
            <summary>
            Max Consecutive failures before an algorithm is omitted from the list of tested algorithms
            </summary>
        </member>
        <member name="F:mapf.Constants.EXHAUSTIVE_ICTS">
            <summary>
            This determines whether the ICTS should search for a solution with lowest conflicts for the ID framework
            </summary>
        </member>
        <member name="F:mapf.Constants.ALLOW_HEAD_ON_COLLISION">
            <summary>
            Allow head-on collisions
            </summary>
        </member>
        <member name="F:mapf.Constants.ALLOW_DIAGONAL_MOVE">
            <summary>
            FIXME: Diagonal move support should count their cost as sqrt(2)
            </summary>
        </member>
        <member name="M:mapf.ISolver.GetName">
            <summary>
            Return the name of the solver, useful for outputing results.
            </summary>
            <returns>The name of the solver</returns>
        </member>
        <member name="M:mapf.ISolver.Solve">
            <summary>
            Solves the instance that was set by a call to Setup()
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.ISolver.Setup(mapf.ProblemInstance,mapf.Run)">
            <summary>
            Setup the relevant data structures for a run.
            </summary>
            <param name="problemInstance"></param>
            <param name="runner"></param>
        </member>
        <member name="M:mapf.ISolver.Clear">
            <summary>
            Clears the relevant data structures and variables to free memory usage.
            </summary>
        </member>
        <member name="M:mapf.ISolver.GetPlan">
            <summary>
            Returns the found plan, or null if no plan was found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.ISolver.GetSolutionCost">
            <summary>
            Returns the cost of the solution found, or error codes otherwise.
            </summary>
        </member>
        <member name="M:mapf.ISolver.GetSolutionDepth">
            <summary>
            Gets the delta of (actual solution cost - first state heuristics)
            </summary>
        </member>
        <member name="M:mapf.ICbsSolver.Setup(mapf.ProblemInstance,System.Int32,mapf.Run,System.Int32,System.Int32,mapf.MDD)">
            <summary>
            
            </summary>
            <param name="problemInstance"></param>
            <param name="minTimeStep">Used mostly to force constraints to have an effect</param>
            <param name="runner"></param>
            <param name="minCost">
            Goal nodes with a lower cost aren't considered a goal.
            This can be used to improve the heuristic estimate!
            </param>
            <param name="maxCost">If known, can speed up the search (no surplus nodes would be generated)</param>
            <param name="mdd">Optional MDD of cost minCost=maxCost</param>
        </member>
        <member name="M:mapf.IHeuristicSolver`1.GetHeuristic">
            <summary>
            Get the heuristic
            </summary>
            <returns></returns>
        </member>
        <member name="T:mapf.MddMatchAndPrune">
            <summary>
            Used by CostTreeNodeSolverKSimpleMatching (but actually commented out)
            </summary>
        </member>
        <member name="M:mapf.MddMatchAndPrune.#ctor(mapf.Run,mapf.CostTreeNodeSolver)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:mapf.MddMatchAndPrune.buildGeneralMDD">
            <summary>
            Build the generalized MDD
            </summary>
            <returns>Whether it was successful</returns>
        </member>
        <member name="M:mapf.MddMatchAndPrune.Expand(mapf.MddMatchAndPruneState,mapf.successorIterator)">
            <summary>
            expands a given node
            </summary>
            <param name="toExpand"></param>
            <param name="allChildren"></param>
        </member>
        <member name="M:mapf.MddMatchAndPrune.pruneLevel(System.Int32)">
            <summary>
            Prunes a given level according to the edgesMatrix
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:mapf.MddMatchAndPrune.pruneMDDs">
            <summary>
            Prunes the given MDDs according to each other
            </summary>
            <returns>Whether it was successful, by how much to increment edgesMatrixCounter, and by how much to increment matchCounter</returns>
        </member>
        <member name="M:mapf.successorIterator.getNext">
            <summary>
            Return the next generated child.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.successorIterator.nextSuccessor(System.Int32)">
            <summary>
            Sets the next child in line for a given agent, if it's the last child returns the first in order (closed loop). If reset returns false.
            </summary>
            <param name="agent"></param>
        </member>
        <member name="M:mapf.successorIterator.nextChild(System.Int32)">
            <summary>
            Recursive function, try to proceed the first agent if it is at the end of its children resets him and proceeds the second agent and so on
            </summary>
            <param name="agent"></param>
        </member>
        <member name="M:mapf.successorIterator.isLegal(System.Int32)">
            <summary>
            If we move the i'th agent we check whether it is legal with all agents that moved before,
            i.e. from that point forward
            </summary>
            <param name="checkFrom"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.Plan">
            <summary>
            Represents a plan for a set of agents.
            </summary>
        </member>
        <member name="M:mapf.Plan.#ctor(mapf.WorldState)">
            <summary>
            Reconstructs the plan by goind backwards from the goal.
            </summary>
            <param name="goalState">The goal state from which to start going backwards</param>
        </member>
        <member name="M:mapf.Plan.#ctor(mapf.AgentState)">
            <summary>
            Reconstructs the plan by going backwards from the goal.
            </summary>
            <param name="goalState">The goal state from which to start going backwards</param>
        </member>
        <member name="M:mapf.Plan.#ctor(System.Collections.Generic.LinkedList{mapf.Move}[])">
            <summary>
            Assumes all routes are of the same length.
            </summary>
            <param name="routePerAgent"></param>
        </member>
        <member name="M:mapf.Plan.#ctor(System.Collections.Generic.IEnumerable{mapf.Plan})">
            <summary>
            Generates a big plan from a collection of smaller plans.
            </summary>
            <param name="subplans"></param>
        </member>
        <member name="M:mapf.Plan.#ctor(mapf.Plan)">
            <summary>
            Medium-depth copy constructor - uses same Move objects.
            </summary>
            <param name="cpy"></param>
        </member>
        <member name="M:mapf.Plan.ContinueWith(mapf.Plan)">
            <summary>
            Add actions of other plan after actions of plan.
            If this plan ends where the other starts,
            the first timestep of the other plan is skipped.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:mapf.Plan.GetLocationsAt(System.Int32)">
            <summary>
            Returns the location of the agents at a given time. 
            If the requested time is after the last step of the plan,
            the agents are assumed to stay at their final location.
            </summary>
            <param name="time">The requested time</param>
            <returns>A list of Moves that are the locations of the different agents at the requested time</returns>
        </member>
        <member name="M:mapf.Plan.GetSize">
            <summary>
            NOT the cost, which:
            A) could depend on steps taken before solving started,
            B) is 1 smaller than the size (a plan that starts at the goal costs zero)
            C) under sum-of-costs, is the sum of the agent costs
            Useful only for iteration over the relevant part of the plan.
            </summary>
            <returns>The size of the plan, assuming is doesn't end with steps where all agents WAIT at the goal (which should be discounted).</returns>
        </member>
        <member name="M:mapf.Plan.IsColliding(System.Int32,mapf.Plan)">
            <summary>
            Check if this plan collides with another plan at a given time
            </summary>
            <param name="time">The time at which to check if the collision occured</param>
            <param name="otherPlan">The plan to check against</param>
        </member>
        <member name="M:mapf.Plan.PrintPlan">
            <summary>
            Prints the plan to the Console. 
            This is used for debugging purposes.
            </summary>
        </member>
        <member name="M:mapf.SinglePlan.#ctor(mapf.WorldState,System.Int32)">
            <summary>
            Not used
            </summary>
            <param name="goalState"></param>
            <param name="agentIndex"></param>
        </member>
        <member name="M:mapf.SinglePlan.#ctor(mapf.Plan,System.Int32,System.Int32)">
            <summary>
            Get a SinglePlan from a Plan
            </summary>
            <param name="plan"></param>
            <param name="agentIndex">In this plan</param>
            <param name="agentNum">To put in the returned SinglePlan</param>
        </member>
        <member name="M:mapf.SinglePlan.GetLocationAt(System.Int32)">
            <summary>
            TODO: Get rid of the else
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.SinglePlan.ContinueWith(mapf.SinglePlan)">
            <summary>
            Add actions of other plan after actions of plan.
            If this plan ends where the other starts,
            the first timestep of the other plan is skipped
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:mapf.SinglePlan.GetSize">
            <summary>
            NOT the cost, which:
            A) could depend on steps taken before solving started,
            B) is 1 smaller than the size (a plan that starts at the goal costs zero)
            Useful only for iteration over the relevant part of the plan.
            </summary>
            <returns>The size of the plan, excluding WAITs at the goal</returns>
        </member>
        <member name="M:mapf.SinglePlan.GetCost">
            <summary>
            TODO: Find all "GetSize() - 1" uses and replace them with this method
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.SinglePlan.IsColliding(System.Int32,mapf.SinglePlan)">
            <summary>
            Check if this plan collides with another plan at a given time
            </summary>
            <param name="time">The time at which to check if the collision occured</param>
            <param name="otherPlan">The plan to check against</param>
        </member>
        <member name="M:mapf.SinglePlan.DebugPrint">
            <summary>
            Prints the plan to the Console. 
            This is used for debugging purposes.
            </summary>
        </member>
        <member name="M:mapf.SinglePlan.GetSinglePlans(System.Collections.Generic.LinkedList{mapf.Move}[])">
            <summary>
            Creates SinglePlans with agentIndex as agentNum. Not suitable for subproblems.
            </summary>
            <param name="allRoutes"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.A_Star_WithRID">
            <summary>
            This Solver runs A* but from time to time tries to solve completely the expanded node
            using Standley's independence detection.
            </summary>
        </member>
        <member name="T:mapf.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:mapf.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:mapf.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:mapf.SumIndividualCosts">
            <summary>
            This class forms a wrapper around problem.GetSingleAgentOptimalCost().
            It represents the single shortest path heuristic, precomputed for every agent.
            </summary>
        </member>
        <member name="M:mapf.SumIndividualCosts.estimateSize">
            <summary>
            Since this class simply refers via a table-lookup to the globally
            available problem.GetSingleAgentOptimalCost class, we incur no memory.
            </summary>
            <returns>0 by definition.</returns>
        </member>
        <member name="M:mapf.SumIndividualCosts.build">
            <summary>
            The building function for this class doesn't do anything because we
            are simply wrapping the functionality of the problem.GetSingleAgentOptimalCost
            class.
            </summary>
        </member>
        <member name="M:mapf.SumIndividualCosts.h(mapf.WorldState)">
            <summary>
            Returns the heuristic estimate.
            </summary>
            <param name="s">The current state.</param>
            <returns>The PDB entry for the given state.</returns>
        </member>
        <member name="M:mapf.SumIndividualCosts.OutputStatisticsHeader(System.IO.TextWriter)">
            <summary>
            Prints header of statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.SumIndividualCosts.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output.
            </summary>
        </member>
        <member name="M:mapf.SumIndividualCosts.ClearStatistics">
            <summary>
            Clears statistics.
            </summary>
        </member>
        <member name="T:mapf.MaxIndividualCosts">
            <summary>
            This class forms a wrapper around problem.GetSingleAgentOptimalCost().
            It represents the single shortest path heuristic for makespan, precomputed for every agent.
            </summary>
        </member>
        <member name="M:mapf.MaxIndividualCosts.estimateSize">
            <summary>
            Since this class simply refers via a table-lookup to the globally
            available problem.GetSingleAgentOptimalCost class, we incur no memory.
            </summary>
            <returns>0 by definition.</returns>
        </member>
        <member name="M:mapf.MaxIndividualCosts.build">
            <summary>
            The building function for this class doesn't do anything because we
            are simply wrapping the functionality of the problem.GetSingleAgentOptimalCost
            class.
            </summary>
        </member>
        <member name="M:mapf.MaxIndividualCosts.h(mapf.WorldState)">
            <summary>
            Returns the heuristic estimate.
            </summary>
            <param name="s">The current state.</param>
            <returns>The PDB entry for the given state.</returns>
        </member>
        <member name="M:mapf.MaxIndividualCosts.OutputStatisticsHeader(System.IO.TextWriter)">
            <summary>
            Prints header of statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.MaxIndividualCosts.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output.
            </summary>
        </member>
        <member name="M:mapf.MaxIndividualCosts.ClearStatistics">
            <summary>
            Clears statistics.
            </summary>
        </member>
        <member name="T:mapf.EnumeratedPDB">
            <summary>
            Represents a pattern database that enumerates all possible
            configurations of the state space by mapping each state to a unique
            32-bit integer. A lookup table in memory maps each 32-bit integer
            representation of the state to a heuristic estimate. In order to reduce
            memory consumption even further, the heuristic estimates are internally
            stored as the difference on top of the single shortest path heuristic.
            The hope is that the reduced magnitude of heuristic values will now
            always fit within the range of a single unsigned byte. This assumption,
            of course, will break on instances that are large enough to cause an
            overflow.
            </summary>
        </member>
        <member name="F:mapf.EnumeratedPDB.table">
            <summary>
            The index is the hash of the state, and the resulting value should
            be added to that reported by the true path heuristic in order to
            get the correct admissible heuristic value. We reserve Byte.MaxValue
            to represent an uninitialized table entry.
            </summary>
        </member>
        <member name="F:mapf.EnumeratedPDB.permutations">
            <summary>
            permutations[i] represents the number of permutations of the
            remaining agents after placing the ith agent. For example, if we
            had 10 agents, and we've already placed 3 of them, then
            permutations[2] represents the number of permutations for the
            remaining 7 agents. This precomputed table depends on the number
            of free locations in the board and is used as a perfect hash 
            function that maps a state in the search space to an integer.
            </summary>
        </member>
        <member name="F:mapf.EnumeratedPDB.offsetFromSingleShortestPath">
            <summary>
            Determines whether or not we will internally represent heuristic
            values as offsets from the single shortest path heuristic.
            </summary>
        </member>
        <member name="T:mapf.EnumeratedPDB.Context">
            <summary>
            Encapsulates the two file streams we will be using as we are
            building the pattern database. These two file streams represent the
            nodes we will be reading for input, and the resulting generated
            children nodes which will be outputted to the second file. We also
            include certain measures such as the number of nodes that have been
            written to a file, and the filenames.
            </summary>
        </member>
        <member name="M:mapf.EnumeratedPDB.Context.NextLevel">
            <summary>
            After processing all of the nodes in one level, and writing the
            resulting children nodes to the next file, we are now ready to
            process the next file. Therefore, we simply swap the input for
            the output file stream.
            </summary>
        </member>
        <member name="M:mapf.EnumeratedPDB.estimateSize">
            <summary>
            The size of an enumerative pattern database based on our member
            variables is simply as many permutations as possible given the
            number of agents and the free locations. Note there may be some
            additional constant overhead associated with this class.
            </summary>
            <returns>An estimate of the amount of memory required for this
            pattern database in units of bytes.</returns>
        </member>
        <member name="M:mapf.EnumeratedPDB.Init(mapf.ProblemInstance,System.Collections.Generic.List{System.UInt32})">
            <summary>
            The initialization function accepts a problem instance describing
            the original full problem, and a list of agents for which this
            pattern database will be responsible for. This must be called prior
            to a call to build the pattern database.
            </summary>
            <param name="pi">A description of the problem instance.</param>
            <param name="agentsToConsider">The agents that we should be responsible for.
            Each entry in the list is an index to ProblemInstance.agents
            pointing to which agents we care about.</param>
        </member>
        <member name="M:mapf.EnumeratedPDB.build">
            <summary>
            Builds the pattern database, storing the heuristic table in memory.
            </summary>
        </member>
        <member name="M:mapf.EnumeratedPDB.h(mapf.WorldState)">
            <summary>
            Returns the heuristic estimate for the subset of agents of the
            given state that this pattern database is responsible for.
            </summary>
            <param name="s">The current state.</param>
            <returns>The PDB entry for the given state.</returns>
        </member>
        <member name="M:mapf.EnumeratedPDB.hash(mapf.WorldState)">
            <summary>
            While working on the original search problem, we have to only pay
            attention to a subset of all of the agents in the current state.
            Specifically, we only consider the agents listed in agents,
            which are the agents that we've built the current pattern database
            for. This differs from the buildHash function, which hashes all
            agents in the given state.
            </summary>
            <param name="s">A state which includes all of the agents in the
            original search problem.</param>
            <returns>An index into the table of heuristic values.</returns>
        </member>
        <member name="M:mapf.EnumeratedPDB.computePermutations">
            <summary>
            We precompute the total number of permutations for a given number
            of agents. We refer to these precomputed values when we call our
            hash function.
            </summary>
        </member>
        <member name="F:mapf.PDB.agentsToConsider">
            <summary>
            The agents to extract from the state. Each value in this list is an
            index into the <see cref="T:mapf.WorldState"/>.allAgentsStates array. This is
            ignored while we are building the pattern database (because it is
            assumed that we are initialized by a root node that contains only
            the agents we are interested in), but is used during the search effort
            in the real problem.
            </summary>
        </member>
        <member name="M:mapf.PDB.Init(mapf.ProblemInstance,System.Collections.Generic.List{System.UInt32})">
            <summary>
            Initializes the pattern database by storing references to the
            problem instance and also the subset of agents that the pattern
            database pertains to.
            </summary>
            <param name="pi">The problem instance.</param>
            <param name="agentsToConsider">The agents that the pattern database should keep track of.</param>
        </member>
        <member name="M:mapf.PDB.estimateSize">
            <summary>
            Returns an estimate of the amount of memory in bytes that is
            required to keep this PDB in memory. This is useful in
            determining how many agents we should allocate to a particular
            pattern database to efficiently utilize our available memory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.PDB.Expand(mapf.WorldState,System.Collections.Generic.ICollection{mapf.WorldState})">
            <summary>
            Expands a node. This is done recursively - generating agent possibilities one at a time.
            This includes:
            - Generating the children
            - Inserting them into OPEN
            - Insert node into CLOSED
            Why does a PDB need to know how to expand nodes? Seems like someone else's job
            </summary>
            <param name="currentNode">The node to expand</param>
            <param name="children">The generated nodes will be filled into this collection</param>
        </member>
        <member name="M:mapf.PDB.Expand(mapf.WorldState,System.Int32,System.Collections.Generic.ICollection{mapf.WorldState},System.Collections.Generic.ICollection{mapf.Move})">
            <summary>
            Expands a node. This is done recursively - generating agent possibilities one at a time.
            This includes:
            - Generating the children
            - Inserting them into OPEN
            - Insert node into CLOSED
            </summary>
            <param name="currentNode">The node to expand</param>
            <param name="agentIndex">The index of the agent to expand children for</param>
            <param name="children">A list in which to set the children states</param>
            <param name="previousMoves">A collection of moves performed by the previous agents in this time step (needed to verify that no collisions occur)</param>
        </member>
        <member name="M:mapf.PDB.IsValid(mapf.Move,System.Int32,System.Collections.Generic.ICollection{mapf.Move})">
            <summary>
            Check if the move is valid, i.e. not colliding into walls or other agents.
            </summary>
            <param name="possibleMove">The proposed move (to check if it is valid)</param>
            <param name="agentNum">The index of the agent that is proposed to perform the move</param>
            <param name="previousAgentMoves">A collection of moves that will be done by the other agents</param>
            <returns></returns>
        </member>
        <member name="M:mapf.PDB.OutputStatisticsHeader(System.IO.TextWriter)">
            <summary>
            Prints header of statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.PDB.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output.
            </summary>
        </member>
        <member name="M:mapf.PDB.ClearStatistics">
            <summary>
            Clears statistics.
            </summary>
        </member>
        <member name="T:mapf.ProblemInstance">
            <summary>
            This class represents a cooperative pathfinding problem instance. This includes:
            - The grid in which the agents are located
            - An array of initial state for every agent.
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.EXPORT_DELIMITER">
            <summary>
            Delimiter used for export/import purposes
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.parameters">
            <summary>
            This contains extra data of this problem instance (used for special problem instances, e.g. subproblems of a bigger problem instance).
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.grid">
            <summary>
            Contains true at [x][y] if cell (x,y) is an obstacle
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.agents">
            <summary>
            We keep a reference to the array of agents in the original problem.
            This will only change when IndependenceDetection's algorithm determines in another
            iteration that a new set of agents must be jointly planned due
            to their mutual conflicts.
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.singleAgentOptimalCosts">
            <summary>
            This is a matrix that contains the cost of the optimal path to the goal of every agent from any point in the grid.
            The first dimension of the matrix is the number of agents.
            The second dimension of the matrix is the cardinality of the location from which we want the shortest path.
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.shortestPathComputeTime">
            <summary>
            The time it took to compute the shortest paths.
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.singleAgentOptimalMoves">
            <summary>
            This is a matrix that contains the best move towards the goal of every agent from any point in the grid.
            The first dimension of the matrix is the number of agents.
            The second dimension of the matrix is the cardinality of the location from which we want the shortest path.
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.agentDistancesToGoal">
            <summary>
            Matrix that contains for each agent it's distance (shortest path) to goal
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.distanceBetweenAgentStartPoints">
            <summary>
            Matrix that contains for each two agents the distance between their starting points
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.distanceBetweenAgentGoals">
            <summary>
            Matrix that contains for each two agents the distance between their goals
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.instanceId">
            <summary>
            This field is used to identify an instance when running a set of experiments
            </summary>
        </member>
        <member name="F:mapf.ProblemInstance.cardinality">
            <summary>
            Enumerates all of the empty spots in the grid. The indices
            correspond directly to those used in the grid, where the major
            index corresponds to the x-axis and the minor index corresponds to
            the y-axis. If there are obstacles, it's more space-efficient to store
            data for each non-empty spot.
            </summary>
        </member>
        <member name="M:mapf.ProblemInstance.Subproblem(mapf.AgentState[])">
            <summary>
            Create a subproblem of this problem instance, in which only part of the agents are regarded.
            </summary>
            <param name="selectedAgents">The selected agent states that will be the root of the subproblem.</param>
            <returns></returns>
        </member>
        <member name="M:mapf.ProblemInstance.Init(mapf.AgentState[],System.Boolean[][],System.Int32,System.Int32,System.Int32[0:,0:])">
            <summary>
            Initialize the members of this object, such that the given agent states are the start state of this instance.
            </summary>
            <param name="agentStartStates"></param>
            <param name="grid"></param>
            <param name="nObstacles"></param>
            <param name="nLocations"></param>
            <param name="cardinality"></param>
        </member>
        <member name="M:mapf.ProblemInstance.ComputeSingleAgentShortestPaths">
            <summary>
            Compute the shortest path to the goal of every agent in the problem instance, from every location in the grid.
            Current implementation is a simple breadth-first search from every location in the graph.
            </summary>
        </member>
        <member name="M:mapf.ProblemInstance.AllShortestPathsTo(mapf.AgentState)">
            <summary>
            Computes the shortest path to the goal for a given agent from every location in the grid.
            Current implementation is a simple breadth-first search from every location in the graph.
            </summary>
            <param name="state">Agent's goal state</param>
            <returns>Tuple with shortestPathLengths and optimalMoves </returns>
        </member>
        <member name="M:mapf.ProblemInstance.ShortestPathFromAToB(mapf.AgentState,mapf.Move)">
            <summary>
            Compute shortest path from starting state to goal
            </summary>
            <param name="startState"></param>
            <param name="goal"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.ProblemInstance.GetSingleAgentOptimalCost(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the length of the shortest path between a given coordinate and the goal location of the given agent.
            </summary>
            <param name="agentNum"></param>
            <param name="x"></param>
            <param name="y"></param>
            <returns>The length of the shortest path from x,y to the goal of the agent.</returns>
        </member>
        <member name="M:mapf.ProblemInstance.GetSingleAgentOptimalCost(System.Int32,mapf.Move)">
            <summary>
            Returns the length of the shortest path between a given coordinate and the goal location of the given agent.
            </summary>
            <param name="agentNum"></param>
            <param name="move"></param>
            <returns>The length of the shortest path from x,y to the goal of the agent.</returns>
        </member>
        <member name="M:mapf.ProblemInstance.GetSingleAgentOptimalCost(mapf.AgentState)">
            <summary>
            Returns the length of the shortest path between a given agent's location and the goal of that agent.
            </summary>
            <param name="agentState"></param>
            <returns>The length of the shortest path between a given agent's location and the goal of that agent</returns>
        </member>
        <member name="M:mapf.ProblemInstance.GetSingleAgentOptimalMove(mapf.AgentState)">
            <summary>
            Returns the optimal move towards the goal of the given agent. Move isn't necessarily unique.
            </summary>
            <param name="agentState"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.ProblemInstance.GetSingleAgentOptimalPlan(mapf.AgentState)">
            <summary>
            Note: The returned plan wasn't constructed considering a CAT, so it's possible there's an alternative plan with the same cost and less collisions.
            </summary>
            <param name="agentState"></param>
            <returns>An optimal plan for the agent, ignoring all others</returns>
        </member>
        <member name="M:mapf.ProblemInstance.AverageStartDistances">
            <summary>
            Compute Average distance between starting points of all agents
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.ProblemInstance.AverageGoalDistances">
            <summary>
            Compute Average distance between goals of all agents
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.ProblemInstance.RatioOfPointsAtSP">
            <summary>
            Compute the ratio of points at the grid which are part of a shortest path
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.ProblemInstance.GetNumOfAgents">
            <summary>
            Utility function that returns the number of agents in this problem instance.
            </summary>
        </member>
        <member name="M:mapf.ProblemInstance.GetMaxX">
            <summary>
            Utility function that returns the x dimension of the grid
            </summary>
        </member>
        <member name="M:mapf.ProblemInstance.GetMaxY">
            <summary>
            Utility function that returns the y dimension of the grid
            </summary>
        </member>
        <member name="M:mapf.ProblemInstance.Import(System.String,System.String)">
            <summary>
            Imports a problem instance from a given file
            </summary>
            <param name="filePath"></param>
            <param name="mapFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.ProblemInstance.Export(System.String)">
            <summary>
            Exports a problem instance to a file
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:mapf.ProblemInstance.GetCardinality(mapf.Move)">
            <summary>
            Given an agent located at the nth location on our board that is
            not occupied by an obstacle, we return n.
            </summary>
            <param name="move">An agent's current location.</param>
            <returns>n, where the agent is located at the nth non-obstacle
            location in our grid.</returns>
        </member>
        <member name="M:mapf.ProblemInstance.IsValid(mapf.Move)">
            <summary>
            Check if the tile is valid, i.e. in the grid and without an obstacle.
            NOT checking the direction. A Move could be declared valid even if it came to an edge tile from outside the grid!
            NOT checking if the move is illegal
            </summary>
            <param name="aMove"></param>
            <returns>True if the given location is a valid grid location with no obstacles</returns>
        </member>
        <member name="M:mapf.ProblemInstance.IsValid(mapf.TimedMove)">
            <summary>
            Also checks if the move is illegal
            </summary>
            <param name="toCheck"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.Move">
            <summary>
            This class represents a single move of an agent. 
            It includes the target location of the move and the direction of the move.
            The start location can be extracted using the direction, with the method GetSource().
            </summary>
        </member>
        <member name="F:mapf.Move.Direction.NO_DIRECTION">
            <summary>
            This constant is set to the direction field to mark that this move does not hold a direction.
            <remarks> 
            Directionless moves are a poor design choice instead of making a class that represents a 2D point,
            but will probably be more efficient.
            </remarks>
            </summary>
        </member>
        <member name="F:mapf.Move.deltasToDirection">
            <remarks>
            Deltas have to be used +1
            </remarks>
        </member>
        <member name="M:mapf.Move.GetNextMoves">
            <summary>
            A generator yielding new adjacent Moves
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.Move.Update(mapf.Move.Direction)">
            <summary>
            Change coordinates in specified direction.
            </summary>
            <param name="direction"></param>
        </member>
        <member name="M:mapf.Move.GetMoveWithoutDirection">
            <summary>
            Returns a copy of this move, where the direction is set to Move.Direction.NO_DIRECTION
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.Move.setOppositeMove">
            <summary>
            Changes this move to represent its opposite. Warning: Changes the hash. Not safe after the object is put in a hash table!
            </summary>
        </member>
        <member name="M:mapf.Move.RemoveDirection">
            <summary>
            Removes the direction of this Move
            </summary>
        </member>
        <member name="M:mapf.Move.IsColliding(mapf.Move)">
            <summary>
            Check if the given move collides with this move.
            This includes:
            1. Head on collision
            2. When other move targets the same location.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.Move.IsColliding(System.Int32,System.Int32,mapf.Move.Direction)">
            <summary>
            Check if colliding with an agent moving to the given x,y from the given direction.
            This includes:
            1. Head on collision
            2. When other move targets the same location.
            TODO: When diagonal moves are allowed, need to also check for diagonal collisions, e.g., (0,0)->(1,1) and (0,1)->(1,0) and such.
            No rush, though. We don't currently work with diagonal moves.
            </summary>
            <param name="other_x"></param>
            <param name="other_y"></param>
            <param name="other_direction"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.Move.Equals(System.Object)">
            <summary>
            Compare two Move objects. 
            If one of the Move objects does not have a direction that is set (i.e. direction == Move.Direction.NO_DIRECTION)
            then the direction part of the Move is ignored.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.Program">
            <summary>
            This is the entry point of the application. 
            </summary>
        </member>
        <member name="M:mapf.Program.SimpleRun">
            <summary>
            Simplest run possible with a randomly generated problem instance.
            </summary>
        </member>
        <member name="M:mapf.Program.RunInstance(System.String)">
            <summary>
            Runs a single instance, imported from a given filename.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:mapf.Program.RunExperimentSet(System.Int32[],System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Runs a set of experiments.
            This function will generate a random instance (or load it from a file if it was already generated)
            </summary>
        </member>
        <member name="M:mapf.Program.RunDragonAgeExperimentSet(System.Int32,System.String[])">
            <summary>
            Dragon Age experiment
            </summary>
            <param name="numInstances"></param>
            <param name="mapFilePaths"></param>
        </member>
        <member name="M:mapf.Program.Main(System.String[])">
            <summary>
            This is the starting point of the program. 
            </summary>
        </member>
        <member name="T:mapf.Run">
            <summary>
            This class is responsible for running the experiments.
            </summary>
        </member>
        <member name="F:mapf.Run.RESULTS_DELIMITER">
            <summary>
            Delimiter character used when writing the results of the runs to the output file.
            </summary>
        </member>
        <member name="F:mapf.Run.RANDOM_WALK_STEPS">
            <summary>
            Number of random steps performed when generating a new problem instance for choosing a start-goal pair.
            </summary>
        </member>
        <member name="F:mapf.Run.startTime">
            <summary>
            Indicates the starting time in ms for timing the different algorithms.
            </summary>
        </member>
        <member name="F:mapf.Run.resultsWriter">
            <summary>
            This holds an open stream to the results file.
            </summary>
        </member>
        <member name="F:mapf.Run.rand">
            <summary>
            EH: I introduced this variable so that debugging and experiments
            can have deterministic results.
            </summary>
        </member>
        <member name="M:mapf.Run.Dispose(System.Boolean)">
            <summary>
            Calls resultsWriter.Dispose()
            </summary>
        </member>
        <member name="M:mapf.Run.OpenResultsFile(System.String)">
            <summary>
            Open the results file for output. Currently the file is opened in append mode.
            </summary>
            <param name="fileName">The name of the results file</param>
        </member>
        <member name="M:mapf.Run.CloseResultsFile">
            <summary>
            Closes the results file.
            </summary>
        </member>
        <member name="F:mapf.Run.solvers">
            <summary>
            All types of algorithms to be run
            </summary>
        </member>
        <member name="F:mapf.Run.astar_heuristics">
            <summary>
            All types of A* heuristics used
            </summary>
        </member>
        <member name="F:mapf.Run.outOfTimeCounters">
            <summary>
            Counts the number of times each algorithm went out of time consecutively
            </summary>
        </member>
        <member name="M:mapf.Run.#ctor">
            <summary>
            Construct with chosen algorithms.
            </summary>
        </member>
        <member name="M:mapf.Run.GenerateProblemInstance(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a problem instance, including a board, start and goal locations of desired number of agents
            and desired precentage of obstacles
            TODO: Refactor to use operators.
            </summary>
            <param name="gridSize"></param>
            <param name="agentsNum"></param>
            <param name="obstaclesNum"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.Run.GenerateDragonAgeProblemInstance(System.String,System.Int32)">
            <summary>
            Generates a problem instance based on a DAO map file.
            TODO: Fix code dup with GenerateProblemInstance and Import later.
            </summary>
            <param name="mapFilePath"></param>
            <param name="agentsNum"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.Run.SolveGivenProblem(mapf.ProblemInstance,System.String)">
            <summary>
            Solve given instance with a list of algorithms 
            </summary>
            <param name="instance">The instance to solve</param>
            <returns>Whether any solver succeeded in solving the instance</returns>
        </member>
        <member name="M:mapf.Run.SolveGivenProblemIncrementally(mapf.ProblemInstance)">
            <summary>
            Solve given instance with a list of algorithms 
            </summary>
            <param name="instance">The instance to solve</param>
        </member>
        <member name="M:mapf.Run.run(mapf.ISolver,mapf.ProblemInstance)">
            <summary>
            Solve a given instance with the given solver
            </summary>
            <param name="solver">The solver</param>
            <param name="instance">The problem instance that will be solved</param>
        </member>
        <member name="M:mapf.Run.PrintResultsFileHeader">
            <summary>
            Print the header of the results file
            </summary>
        </member>
        <member name="M:mapf.Run.PrintStatistics(mapf.ProblemInstance,mapf.ISolver,System.Double)">
            <summary>
            Print the solver statistics to the results file.
            </summary>
            <param name="instance">The problem instance that was solved. Not used!</param>
            <param name="solver">The solver that solved the problem instance</param>
            <param name="runtimeInMillis">The time it took the given solver to solve the given instance</param>
        </member>
        <member name="T:mapf.CostTreeSearchSolver">
            <summary>
            This class solves an instance of the MAPF problem using the increasing costs tree search algorithm.
            </summary>
        </member>
        <member name="M:mapf.CostTreeSearchSolver.GetName">
            <summary>
            Return the name of the solver, useful for outputting results.
            </summary>
            <returns>The name of the solver</returns>
        </member>
        <member name="M:mapf.CostTreeSearchSolver.Setup(mapf.ProblemInstance,System.Int32,mapf.Run,System.Int32,System.Int32,mapf.MDD)">
            <summary>
            Setup the relevant data structures for a run.
            </summary>
            <param name="problemInstance"></param>
            <param name="minTimeStep"></param>
            <param name="runner"></param>
            <param name="minCost">FIXME: Not taken into account, just added to comply with ICbsSolver</param>
            <param name="maxCost">FIXME: Not taken into account, just added to comply with ICbsSolver</param>
            <param name="mdd">FIXME: Not taken into account, just added to comply with ICbsSolver</param>
        </member>
        <member name="M:mapf.CostTreeSearchSolver.Clear">
            <summary>
            Clears the relevant data structures and variables to free memory usage.
            </summary>
        </member>
        <member name="M:mapf.CostTreeSearchSolver.GetSolutionCost">
            <summary>
            Returns the cost of the solution found, or error codes otherwise.
            </summary>
        </member>
        <member name="M:mapf.CostTreeSearchSolver.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.CostTreeSearchSolver.Solve">
            <summary>
            Solves the instance that was set by a call to Setup()
            </summary>
            <returns></returns>
        </member>
        <member name="T:mapf.CostTreeNodeSolver">
            <summary>
            This class tries to find a solution to a problem instance of a given cost. 
            (this is used in the CostTreeSearchSolver)
            </summary>
        </member>
        <member name="M:mapf.CostTreeNodeSolver.#ctor(mapf.ProblemInstance,mapf.Run,mapf.CostTreeSearchSolver,System.Int32[],mapf.CostTreeNode)">
            <summary>
            
            </summary>
            <param name="problem"></param>
            <param name="runner"></param>
            <param name="solver"></param>
            <param name="agentNums"></param>
            <param name="costsNode">Of all the agents, not just the ones selected</param>
        </member>
        <member name="M:mapf.CostTreeNodeSolver.#ctor(mapf.ProblemInstance,mapf.CostTreeNode,mapf.Run,mapf.CostTreeSearchSolver)">
            <summary>
            Automatically calls Setup with the given costsNode
            </summary>
            <param name="problem"></param>
            <param name="costNode">TODO: Maybe just pass the array of costs here?</param>
            <param name="runner"></param>
            <param name="solver"></param>
        </member>
        <member name="M:mapf.CostTreeNodeSolver.Solve(System.Collections.Generic.Dictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}},System.Collections.Generic.Dictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Tries to find a solution for the agents with the given cost.
            </summary>
            <returns>The solution if found or null otherwise</returns>
        </member>
        <member name="T:mapf.CostTreeNodeSolverOldMatching">
            <summary>
            Use this one!
            </summary>
        </member>
        <member name="F:mapf.CostTreeNodeSolverOldMatching.syncSize">
            <summary>
            Currently the only supported values are 3 and non-3. This is equivalent to bool checkTriples.
            </summary>
        </member>
        <member name="M:mapf.CostTreeNodeSolverOldMatching.Solve(System.Collections.Generic.Dictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}},System.Collections.Generic.Dictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Prunes the individual agent MDDs and, if possible, matches them to return a non-conflicting configuration of
            paths of the given costs.
            </summary>
            <param name="ID_CAT"></param>
            <param name="CBS_CAT"></param>
            <returns>
            null if no solution is found.
            </returns>
        </member>
        <member name="M:mapf.CostTreeNodeSolverOldMatching.Prune">
            <summary>
            Prunes the individual agent MDDs and prepares data for matching them
            </summary>
            <returns>Whether everything was pruned</returns>
        </member>
        <member name="T:mapf.TimedMove">
            <summary>
            Describes a Move at a given timestep.
            </summary>
        </member>
        <member name="M:mapf.TimedMove.GetNextMoves">
            <summary>
            A generator yielding new adjacent TimedMoves. Reimplemented to avoid creating temporary Moves.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.TimedMove.Update(mapf.Move.Direction)">
            <summary>
            Change coordinates in specified direction and increment timestep.
            </summary>
            <param name="direction"></param>
        </member>
        <member name="M:mapf.TimedMove.IsColliding(mapf.TimedMove)">
            <summary>
            Check if the given move collides with this move.
            This includes:
            0. Same time
            1. Head on collision
            2. When other moves target the same location.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.TimedMove.GetOppositeMove">
            <summary>
            Reimplemented to avoid creating temporary Move objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.TimedMove.setup(mapf.Move,System.Int32)">
            <summary>
            Isn't used anywhere
            </summary>
            <param name="cpy"></param>
            <param name="time"></param>
        </member>
        <member name="M:mapf.TimedMove.setup(mapf.TimedMove)">
            <summary>
            
            </summary>
            <param name="cpy"></param>
        </member>
        <member name="M:mapf.TimedMove.setup(System.Int32,System.Int32,mapf.Move.Direction,System.Int32)">
            <summary>
            Almost isn't used anywhere
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="direction"></param>
            <param name="time"></param>
        </member>
        <member name="M:mapf.TimedMove.GetColliding(System.Collections.Generic.IReadOnlyDictionary{mapf.TimedMove,System.Int32})">
            <summary>
            Gets a dictionary mapping TimedMoves to the agent that already made them
            and returns a list of agents this TimedMove collides with.
            </summary>
            <param name="timedMovesToAgentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.TimedMove.GetColliding(System.Collections.Generic.IReadOnlyDictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Gets a dictionary mapping TimedMoves to the agents that already made them
            and returns a list of agents this TimedMove collides with.
            </summary>
            <param name="timedMovesToAgentNumLists"></param>
            <returns></returns>
        </member>
        <member name="F:mapf.IndependenceDetection.plan">
            <summary>
            The complete plan for all the agents that was found.
            </summary>
        </member>
        <member name="M:mapf.IndependenceDetection.CalculateJointPlan">
            <summary>
            Calculate the full plan for all the agents that has been found by the algorithm
            </summary>
        </member>
        <member name="M:mapf.IndependenceDetection.OutputStatistics(System.IO.TextWriter)">
            <summary>
            Prints statistics of a single run to the given output. 
            </summary>
        </member>
        <member name="M:mapf.IndependenceDetection.GetMaxGroupSize">
            <summary>
            Also calculates min group size and max solution depth on the way.
            FIXME: Code dup!
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.IndependenceDetection.FindConflictingGroups">
            <summary>
            Simulates the execution of the plans found for the different groups. 
            If there are conflicting plans - return the conflicting groups.
            </summary>
            <returns>A conflict object with data about the found conflict, or null if no conflict exists</returns>
        </member>
        <member name="M:mapf.IndependenceDetection.SimpleID(mapf.Run)">
            <summary>
            Search for an optimal solution using the Simple Independence Detection algorithm from Trevor Standley's paper.
            </summary>
            <param name="runner"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.IndependenceDetection.ImprovedID(mapf.Run)">
            <summary>
            Search for an optimal solution using the Independence Detection algorithm in Standley's paper,
            which utilises a CAT.
            </summary>
            <param name="runner"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.IndependenceDetection.JoinGroups(mapf.IndependenceDetectionConflict)">
            <summary>
            Join the conflicting groups into a single group
            </summary>
            <param name="conflict">An object that describes the conflict</param>
            <returns>The composite group of agents</returns>
        </member>
        <member name="M:mapf.IndependenceDetection.Solve">
            <summary>
            Run the A* algorithm with Standley's ID and OD improvements.
            </summary>
            <returns>true if optimal solution has been found</returns>
        </member>
        <member name="T:mapf.IndependenceDetectionAgentsGroup">
            <summary>
            This class represents a group of agents that need to be solved together.
            </summary>
        </member>
        <member name="M:mapf.IndependenceDetectionAgentsGroup.Solve(mapf.Run)">
            <summary>
            Solve the group of agents together.
            </summary>
            <param name="runner"></param>
            <returns>true if optimal solution for the group of agents were found, false otherwise</returns>
        </member>
        <member name="M:mapf.IndependenceDetectionAgentsGroup.GetPlan">
            <summary>
            Returns the plan for the group of agents. This is a collection of Moves for every time step until all the agents reach their goal.
            </summary>
        </member>
        <member name="M:mapf.IndependenceDetectionAgentsGroup.Join(mapf.IndependenceDetectionAgentsGroup)">
            <summary>
            Joins this and another group to a single group with all of the agents together.
            </summary>
            <param name="other"></param>
            <returns>A new AgentsGroup object with the agents from both this and the other group</returns>
        </member>
        <member name="M:mapf.IndependenceDetectionAgentsGroup.Size">
            <summary>
            Returns the number of agents in the group.
            </summary>
        </member>
        <member name="M:mapf.IndependenceDetectionAgentsGroup.ReplanUnderConstraints(mapf.Plan,mapf.Run)">
            <summary>
            Tries to find a plan for this group, that will not conflict with the given plan,
            and still has the same solution cost as the current solution cost.
            This is used in the ImprovedID() method.
            </summary>
            <param name="plan"></param>
            <param name="runner"></param>
            <returns></returns>
        </member>
        <member name="T:mapf.WorldState">
            <summary>
            Describes a node in the A* search space.
            </summary>
        </member>
        <member name="F:mapf.WorldState.potentialConflictsCount">
            <summary>
            For Independence Detection only
            </summary>
        </member>
        <member name="F:mapf.WorldState.cbsInternalConflicts">
            <summary>
            Maps from agent num to the number of times the path up to this node collides with that agent
            </summary>
        </member>
        <member name="F:mapf.WorldState.conflictTimes">
            <summary>
            Maps from agent num to a list of the conflict times with it
            </summary>
        </member>
        <member name="F:mapf.WorldState.minGoalTimeStep">
            <summary>
            The min depth (makespan) from which a node may be considered a goal.
            TODO: Consider moving out of the node object to a static variable or something.
                  It doesn't change between nodes.
            </summary>
        </member>
        <member name="F:mapf.WorldState.minGoalCost">
            <summary>
            The min cost (g) from which a node may be considered a goal.
            TODO: Consider moving out of the node object to a static variable or something.
                  It doesn't change between nodes.
            </summary>
        </member>
        <member name="F:mapf.WorldState.currentMoves">
            <summary>
            The last move of all agents that have already moved in this turn.
            Used for making sure the next agent move doesn't collide with moves already made.
            Used while generating this node, nullified when done.
            </summary>
        </member>
        <member name="F:mapf.WorldState.expandedCountWhenGenerated">
            <summary>
            For computing expansion delay
            </summary>
        </member>
        <member name="F:mapf.WorldState.collisionSets">
            <summary>
            For MStar.
            Disjoint sets of agent indices, since only internal agents are considered.
            </summary>
        </member>
        <member name="M:mapf.WorldState.#ctor(mapf.AgentState[],System.Int32,System.Int32,mapf.MDDNode)">
            <summary>
            Create a state with the given state for every agent.
            </summary>
            <param name="allAgentsState"></param>
            <param name="minDepth"></param>
            <param name="minCost"></param>
            <param name="mddNode"></param>
        </member>
        <member name="M:mapf.WorldState.#ctor(mapf.WorldState)">
            <summary>
            Copy constructor.
            </summary>
            <param name="cpy"></param>
        </member>
        <member name="M:mapf.WorldState.#ctor(mapf.AgentState[],System.Collections.Generic.List{System.UInt32})">
            <summary>
            Creates a new state by extracting a subset of the agents from
            the original WorldState. We overload the constructor because
            while building our pattern database, we rewrite the problem and
            therefore need to make a deep copy of the state data structures so
            as to not overwrite the original problem. The ultimate solution
            would be to rework the code to remove static variables so that we
            can instantiate subproblems without affecting the original data
            structures.
            </summary>
            <param name="allAgentsState">A set of agent states in the original problem.</param>
            <param name="agentIndicesToCopy">A list of indices referring to the subset of agents we want to extract.</param>
        </member>
        <member name="M:mapf.WorldState.SetSolution(mapf.SinglePlan[])">
            <summary>
            Set the optimal solution of this node as a problem instance.
            Currently only used by CbsHeuristicForAStar, if a solution was found while running the heuristic.
            </summary>
            <param name="solution"></param>
        </member>
        <member name="M:mapf.WorldState.GetPlan">
            <summary>
            Returns the optimal plan to the goal through this node, if this is a goal node (of any kind),
            else returns the optimal plan to this node.
            </summary>
            <returns></returns>
        </member>
        <member name="F:mapf.WorldState.goalCost">
            <summary>
            For generalized goal nodes.
            TODO: Get rid of this and just return the sum/max of the single costs where needed?
            </summary>
        </member>
        <member name="M:mapf.WorldState.GetGoalCost">
            <summary>
            Returns the optimal cost to the goal from the start through this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.SetGoalCost(System.Int32)">
            <summary>
            Set the optimal cost from the start to the goal through this node.
            Makes this a generalized goal node.
            Currently only used by CbsHeuristicForAStar.
            </summary>
            <param name="cost"></param>
        </member>
        <member name="F:mapf.WorldState.goalSingleCosts">
            <summary>
            For generalized goal nodes
            </summary>
        </member>
        <member name="M:mapf.WorldState.SetSingleCosts(System.Int32[])">
            <summary>
            Set the optimal cost from the start to the goal through this node for every agent.
            Makes this node a generalized goal node.
            Currently only used by CbsHeuristicForAStar.
            </summary>
            <param name="costs"></param>
        </member>
        <member name="M:mapf.WorldState.CompareTo(mapf.IBinaryHeapItem)">
            <summary>
            Used when WorldState objects are put in the open list priority queue
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.CalculateG">
            <summary>
            Calculate and set the g of the state as the sum of the different agent g values.
            </summary>
        </member>
        <member name="M:mapf.WorldState.Clear">
            <summary>
            Prepare for re-insertion into the open list
            </summary>
        </member>
        <member name="M:mapf.WorldState.GetAgentsMoves">
            <summary>
            Returns the last move of all the agents in this state.
            </summary>
            <returns>A list of Moves</returns>
        </member>
        <member name="M:mapf.WorldState.GetSingleAgentMove(System.Int32)">
            <summary>
            Returns the last move of the requested agent.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.GetIndexInHeap">
            <summary>
            BH_Item implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.SetIndexInHeap(System.Int32)">
            <summary>
            BH_Item implementation
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.isValid">
            <summary>
            Checks for internal conflicts
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.GetHashCode">
            <summary>
            Only the agent states are used in the hash.
            The g, makespan, h, potentialConflictsCount, cbsInternalConflictsCount and others are ignored, as neccesary.
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.Equals(System.Object)">
            <summary>
            Only the AgentStates are compared.
            g, makespan, h, potentialConflictsCount, cbsInternalConflictsCount and others are ignored, as necessary.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.UpdateConflictCounts(System.Collections.Generic.IReadOnlyDictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Counts the number of times this node collides with each agent move in the conflict avoidance table.
            </summary>
            <param name="conflictAvoidance"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldState.ToProblemInstance(mapf.ProblemInstance)">
            <summary>
            Currently only used by CbsHeuristicForAStar, where each A* node is converted to a new
            MAPF problem to be solved by CBS (or ICTS, theoretically)
            </summary>
            <param name="initial"></param>
            <returns></returns>
        </member>
        <member name="F:mapf.WorldStateForPartialExpansion.targetDeltaF">
            <summary>
            Starts at zero, incremented after a node is expanded once. Set on Expand.
            </summary>
        </member>
        <member name="F:mapf.WorldStateForPartialExpansion.remainingDeltaF">
            <summary>
            Remaining delta F towards targetDeltaF. Reset on Expand.
            </summary>
        </member>
        <member name="F:mapf.WorldStateForPartialExpansion.singleAgentDeltaFs">
            <summary>
            For each agent and each direction it can go, the effect of that move on F
            byte.MaxValue means this is an illegal move. Only computed on demand.
            </summary>
        </member>
        <member name="F:mapf.WorldStateForPartialExpansion.maxDeltaF">
            <summary>
            Only computed on demand
            </summary>
        </member>
        <member name="F:mapf.WorldStateForPartialExpansion.fLookup">
            <summary>
            Per each agent and delta F, has 1 if that delta F is achievable by moving the agents starting from this one on,
            -1 if it isn't, and 0 if we don't know yet.
            Only computed on demand
            </summary>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.#ctor(mapf.AgentState[],System.Int32,System.Int32,mapf.MDDNode)">
            <summary>
            Create a state with the given state for every agent.
            </summary>
            <param name="allAgentsState"></param>
            <param name="minDepth"></param>
            <param name="minCost"></param>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.#ctor(mapf.WorldStateForPartialExpansion)">
            <summary>
            Copy constructor
            </summary>
            <param name="cpy"></param>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.ClearExpansionData">
            <summary>
            From generated nodes. Allows expansion table to be garbage collected before all generated nodes are expanded.
            </summary>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.calcSingleAgentDeltaFs(mapf.ProblemInstance,mapf.WorldStateForPartialExpansion.ValidityChecker)">
            <summary>
            Calculates for each agent and each direction it can go, the effect of that move on F. Illegal moves get byte.MaxValue.
            Also calcs maxDeltaF.
            Implicitly uses the SIC heuristic.
            </summary>
            <param name="problem">For GetSingleAgentOptimalCost</param>
            <param name="isValid"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.hasMoreChildren">
            <summary>
            Returns whether all possible f values were generated from this node already
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.existsChildForF(System.Int32,System.UInt16)">
            <summary>
            Recursive func. Kind of dynamic programming as it updates the lookup table as it goes to refrain from computing answers twice.
            </summary>
            <param name="agentNum"></param>
            <param name="remainingTargetDeltaF"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.UpdateRemainingDeltaF(System.Int32)">
            <summary>
            An agent was moved between calculating the singleAgentDeltaFs and this call.
            Using the data that describes its delta F potential before the move.
            </summary>
            <param name="agentIndex"></param>
        </member>
        <member name="M:mapf.WorldStateForPartialExpansion.Clear">
            <summary>
            For fully expanded nodes.
            Notice ClearExpansionData does a similar thing, but for different reasons.
            </summary>
        </member>
        <member name="T:mapf.WorldStateWithOD">
            <summary>
            This class represents a state in the A* search with operator decomposition,
            as proposed by Scott Standley's AAAI paper in 2010.
            More specifically, states can represent a partial move, in which only some of the agents have moved
            and the other have not yet moved in this turn. 
            </summary>
        </member>
        <member name="F:mapf.WorldStateWithOD.agentTurn">
            <summary>
            Marks the index of the agent that will move next. 
            All agents with index less than agentTurn are assumed to have already chosen their move for this time step,
            while agents with higher index have not chosen their move yet.
            </summary>
        </member>
        <member name="M:mapf.WorldStateWithOD.#ctor(mapf.AgentState[],System.Collections.Generic.List{System.UInt32})">
            <summary>
            Used for PDB stuff only
            </summary>
            <param name="states"></param>
            <param name="relevantAgents"></param>
        </member>
        <member name="M:mapf.WorldStateWithOD.SetSolution(mapf.SinglePlan[])">
            <summary>
            Set the optimal solution of this node as a problem instance.
            </summary>
            <param name="solution"></param>
        </member>
        <member name="M:mapf.WorldStateWithOD.GetHashCode">
            <summary>
            Returns a hash value for the given state (used in Hash based data structures).
            </summary>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldStateWithOD.CompareTo(mapf.IBinaryHeapItem)">
            <summary>
            Used when WorldStateWithOD objects are put in the open list priority queue.
            All other things being equal, prefers nodes where more agents have moved.
            G is already preferred, but this helps when the last move was a WAIT at the
            goal, which doesn't increment G.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:mapf.WorldStateWithOD.UpdateConflictCounts(System.Collections.Generic.IReadOnlyDictionary{mapf.TimedMove,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Counts for last agent to move only, the counts from the previous agents to move are accumulated from the parent node.
            </summary>
            <param name="conflictAvoidance"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethods.MyExtensions.MaxByKeyFunc``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Like Python's max(x, key=func)
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="sequence"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethods.MyExtensions.IndicesOfMax``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Based on MaxIndex By Jon Skeet: http://stackoverflow.com/questions/462699/how-do-i-get-the-index-of-the-highest-value-in-an-array-using-linq
            </summary>
            <param name="sequence"></param>
            <returns></returns>
        </member>
    </members>
</doc>
